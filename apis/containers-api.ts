/* tslint:disable */
/* eslint-disable */
/**
 * Deep Lynx
 * The construction of megaprojects has consistently demonstrated challenges for project managers in regard to meeting cost, schedule, and performance requirements. Megaproject construction challenges are common place within megaprojects with many active projects in the United States failing to meet cost and schedule efforts by significant margins. Currently, engineering teams operate in siloed tools and disparate teams where connections across design, procurement, and construction systems are translated manually or over brittle point-to-point integrations. The manual nature of data exchange increases the risk of silent errors in the reactor design, with each silent error cascading across the design. These cascading errors lead to uncontrollable risk during construction, resulting in significant delays and cost overruns. Deep Lynx allows for an integrated platform during design and operations of mega projects.  The Deep Lynx Core API delivers a few main features.  1. Provides a set of methods and endpoints for manipulating data in an object oriented database. This allows us to store complex datatypes as records and then to compile them into actual, modifiable objects at run-time. Users can store taxonomies or ontologies in a readable format.  2. Provides methods for storing and retrieving data in a graph database. This data is structured and validated against the aformentioned object oriented database before storage.
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { BatchUpdateRequest } from '../models';
import { ContainerImportSuccess } from '../models';
import { ContainerResponse } from '../models';
import { CreateRequest } from '../models';
import { Generic200 } from '../models';
import { UpdateRequest } from '../models';
/**
 * ContainersApi - axios parameter creator
 * @export
 */
export const ContainersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Archives a Container. This is preferred over deletion as deletion has a cascading effect on the deleted type's keys, relationships, and relationship keys. When in doubt, archive over delete. We'd rather have tombstones than cremating the type.
         * @summary ArchiveContainer
         * @param {string} containerId 
         * @param {boolean} [permanent] If true, permanently deletes the container
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveContainer: async (containerId: string, permanent?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling archiveContainer.');
            }
            const localVarPath = `/containers/{container_id}`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required

            if (permanent !== undefined) {
                localVarQueryParameter['permanent'] = permanent;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Accepts an array of container objects - will attempt to update all of them in a single transaction. If the update fails, none of them will go through.
         * @summary ContainerBatchUpdate
         * @param {Array&lt;BatchUpdateRequest&gt;} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerBatchUpdate: async (body: Array<BatchUpdateRequest>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling containerBatchUpdate.');
            }
            const localVarPath = `/containers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new container object. Containers are the root level object and are considered to contain both the ontology(in form of Metatypes, Metatype Keys, and MetatypeRelationships) as well as the data stored under that ontology.  Endpoint will accept both a single container request object, or an array of container request objects
         * @summary CreateContainer
         * @param {CreateRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainer: async (body: CreateRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createContainer.');
            }
            const localVarPath = `/containers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * An optional query param `dryrun` may be included with a value of `true` in order to return a HTML formatted string explaining the name and description of the container along with the number of metatypes, metatype relationships, and metatype keys to be created. This request uses a form-data body. If the ontology to be imported is being referenced via url, provide the url via a `path` field. Otherwise a local file may be provided. A file takes precedence over a `path` value if both are provided.
         * @summary ImportContainer
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {boolean} [dataVersioningEnabled] 
         * @param {string} [path] 
         * @param {string} [file] 
         * @param {boolean} [dryrun] If true returns a description of the container that will be created and its contents.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importContainer: async (name?: string, description?: string, dataVersioningEnabled?: boolean, path?: string, file?: string, dryrun?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/containers/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication httpBearer required

            if (dryrun !== undefined) {
                localVarQueryParameter['dryrun'] = dryrun;
            }


            if (name !== undefined) { 
                localVarFormParams.set('name', name as any);
            }

            if (description !== undefined) { 
                localVarFormParams.set('description', description as any);
            }

            if (dataVersioningEnabled !== undefined) { 
                localVarFormParams.set('data_versioning_enabled', dataVersioningEnabled as any);
            }

            if (path !== undefined) { 
                localVarFormParams.set('path', path as any);
            }

            if (file !== undefined) { 
                localVarFormParams.set('file', file as any);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * List all containers.
         * @summary ListContainers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainers: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/containers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Repairs a container's permission set
         * @summary RepairContainerPermissions
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repairContainerPermissions: async (containerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling repairContainerPermissions.');
            }
            const localVarPath = `/containers/{container_id}/permissions`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve container by ID.
         * @summary RetrieveContainer
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveContainer: async (containerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling retrieveContainer.');
            }
            const localVarPath = `/containers/{container_id}`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Unarchives a Container. This is the only way to update this value of a container via API.
         * @summary SetContainerActive
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setContainerActive: async (containerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling setContainerActive.');
            }
            const localVarPath = `/containers/{container_id}/active`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the container. This will fail if a container already exists with the proposed updated name.
         * @summary UpdateContainer
         * @param {UpdateRequest} body 
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContainer: async (body: UpdateRequest, containerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateContainer.');
            }
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling updateContainer.');
            }
            const localVarPath = `/containers/{container_id}`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing container via an ontology file.
         * @summary UpdateContainerImport
         * @param {string} containerId 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {boolean} [dataVersioningEnabled] 
         * @param {string} [path] 
         * @param {string} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContainerImport: async (containerId: string, name?: string, description?: string, dataVersioningEnabled?: boolean, path?: string, file?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling updateContainerImport.');
            }
            const localVarPath = `/containers/import/{container_id}`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication httpBearer required


            if (name !== undefined) { 
                localVarFormParams.set('name', name as any);
            }

            if (description !== undefined) { 
                localVarFormParams.set('description', description as any);
            }

            if (dataVersioningEnabled !== undefined) { 
                localVarFormParams.set('data_versioning_enabled', dataVersioningEnabled as any);
            }

            if (path !== undefined) { 
                localVarFormParams.set('path', path as any);
            }

            if (file !== undefined) { 
                localVarFormParams.set('file', file as any);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContainersApi - functional programming interface
 * @export
 */
export const ContainersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Archives a Container. This is preferred over deletion as deletion has a cascading effect on the deleted type's keys, relationships, and relationship keys. When in doubt, archive over delete. We'd rather have tombstones than cremating the type.
         * @summary ArchiveContainer
         * @param {string} containerId 
         * @param {boolean} [permanent] If true, permanently deletes the container
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async archiveContainer(containerId: string, permanent?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Generic200>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).archiveContainer(containerId, permanent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Accepts an array of container objects - will attempt to update all of them in a single transaction. If the update fails, none of them will go through.
         * @summary ContainerBatchUpdate
         * @param {Array&lt;BatchUpdateRequest&gt;} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerBatchUpdate(body: Array<BatchUpdateRequest>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerResponse>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).containerBatchUpdate(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a new container object. Containers are the root level object and are considered to contain both the ontology(in form of Metatypes, Metatype Keys, and MetatypeRelationships) as well as the data stored under that ontology.  Endpoint will accept both a single container request object, or an array of container request objects
         * @summary CreateContainer
         * @param {CreateRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContainer(body: CreateRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerResponse>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).createContainer(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * An optional query param `dryrun` may be included with a value of `true` in order to return a HTML formatted string explaining the name and description of the container along with the number of metatypes, metatype relationships, and metatype keys to be created. This request uses a form-data body. If the ontology to be imported is being referenced via url, provide the url via a `path` field. Otherwise a local file may be provided. A file takes precedence over a `path` value if both are provided.
         * @summary ImportContainer
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {boolean} [dataVersioningEnabled] 
         * @param {string} [path] 
         * @param {string} [file] 
         * @param {boolean} [dryrun] If true returns a description of the container that will be created and its contents.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importContainer(name?: string, description?: string, dataVersioningEnabled?: boolean, path?: string, file?: string, dryrun?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerImportSuccess>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).importContainer(name, description, dataVersioningEnabled, path, file, dryrun, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List all containers.
         * @summary ListContainers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContainers(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerResponse>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).listContainers(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Repairs a container's permission set
         * @summary RepairContainerPermissions
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repairContainerPermissions(containerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Generic200>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).repairContainerPermissions(containerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve container by ID.
         * @summary RetrieveContainer
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveContainer(containerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerResponse>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).retrieveContainer(containerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Unarchives a Container. This is the only way to update this value of a container via API.
         * @summary SetContainerActive
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setContainerActive(containerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Generic200>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).setContainerActive(containerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates the container. This will fail if a container already exists with the proposed updated name.
         * @summary UpdateContainer
         * @param {UpdateRequest} body 
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateContainer(body: UpdateRequest, containerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerResponse>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).updateContainer(body, containerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates an existing container via an ontology file.
         * @summary UpdateContainerImport
         * @param {string} containerId 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {boolean} [dataVersioningEnabled] 
         * @param {string} [path] 
         * @param {string} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateContainerImport(containerId: string, name?: string, description?: string, dataVersioningEnabled?: boolean, path?: string, file?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerImportSuccess>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).updateContainerImport(containerId, name, description, dataVersioningEnabled, path, file, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ContainersApi - factory interface
 * @export
 */
export const ContainersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Archives a Container. This is preferred over deletion as deletion has a cascading effect on the deleted type's keys, relationships, and relationship keys. When in doubt, archive over delete. We'd rather have tombstones than cremating the type.
         * @summary ArchiveContainer
         * @param {string} containerId 
         * @param {boolean} [permanent] If true, permanently deletes the container
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveContainer(containerId: string, permanent?: boolean, options?: any): AxiosPromise<Generic200> {
            return ContainersApiFp(configuration).archiveContainer(containerId, permanent, options).then((request) => request(axios, basePath));
        },
        /**
         * Accepts an array of container objects - will attempt to update all of them in a single transaction. If the update fails, none of them will go through.
         * @summary ContainerBatchUpdate
         * @param {Array&lt;BatchUpdateRequest&gt;} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerBatchUpdate(body: Array<BatchUpdateRequest>, options?: any): AxiosPromise<ContainerResponse> {
            return ContainersApiFp(configuration).containerBatchUpdate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new container object. Containers are the root level object and are considered to contain both the ontology(in form of Metatypes, Metatype Keys, and MetatypeRelationships) as well as the data stored under that ontology.  Endpoint will accept both a single container request object, or an array of container request objects
         * @summary CreateContainer
         * @param {CreateRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainer(body: CreateRequest, options?: any): AxiosPromise<ContainerResponse> {
            return ContainersApiFp(configuration).createContainer(body, options).then((request) => request(axios, basePath));
        },
        /**
         * An optional query param `dryrun` may be included with a value of `true` in order to return a HTML formatted string explaining the name and description of the container along with the number of metatypes, metatype relationships, and metatype keys to be created. This request uses a form-data body. If the ontology to be imported is being referenced via url, provide the url via a `path` field. Otherwise a local file may be provided. A file takes precedence over a `path` value if both are provided.
         * @summary ImportContainer
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {boolean} [dataVersioningEnabled] 
         * @param {string} [path] 
         * @param {string} [file] 
         * @param {boolean} [dryrun] If true returns a description of the container that will be created and its contents.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importContainer(name?: string, description?: string, dataVersioningEnabled?: boolean, path?: string, file?: string, dryrun?: boolean, options?: any): AxiosPromise<ContainerImportSuccess> {
            return ContainersApiFp(configuration).importContainer(name, description, dataVersioningEnabled, path, file, dryrun, options).then((request) => request(axios, basePath));
        },
        /**
         * List all containers.
         * @summary ListContainers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainers(options?: any): AxiosPromise<ContainerResponse> {
            return ContainersApiFp(configuration).listContainers(options).then((request) => request(axios, basePath));
        },
        /**
         * Repairs a container's permission set
         * @summary RepairContainerPermissions
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repairContainerPermissions(containerId: string, options?: any): AxiosPromise<Generic200> {
            return ContainersApiFp(configuration).repairContainerPermissions(containerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve container by ID.
         * @summary RetrieveContainer
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveContainer(containerId: string, options?: any): AxiosPromise<ContainerResponse> {
            return ContainersApiFp(configuration).retrieveContainer(containerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Unarchives a Container. This is the only way to update this value of a container via API.
         * @summary SetContainerActive
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setContainerActive(containerId: string, options?: any): AxiosPromise<Generic200> {
            return ContainersApiFp(configuration).setContainerActive(containerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the container. This will fail if a container already exists with the proposed updated name.
         * @summary UpdateContainer
         * @param {UpdateRequest} body 
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContainer(body: UpdateRequest, containerId: string, options?: any): AxiosPromise<ContainerResponse> {
            return ContainersApiFp(configuration).updateContainer(body, containerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing container via an ontology file.
         * @summary UpdateContainerImport
         * @param {string} containerId 
         * @param {string} [name] 
         * @param {string} [description] 
         * @param {boolean} [dataVersioningEnabled] 
         * @param {string} [path] 
         * @param {string} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContainerImport(containerId: string, name?: string, description?: string, dataVersioningEnabled?: boolean, path?: string, file?: string, options?: any): AxiosPromise<ContainerImportSuccess> {
            return ContainersApiFp(configuration).updateContainerImport(containerId, name, description, dataVersioningEnabled, path, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContainersApi - object-oriented interface
 * @export
 * @class ContainersApi
 * @extends {BaseAPI}
 */
export class ContainersApi extends BaseAPI {
    /**
     * Archives a Container. This is preferred over deletion as deletion has a cascading effect on the deleted type's keys, relationships, and relationship keys. When in doubt, archive over delete. We'd rather have tombstones than cremating the type.
     * @summary ArchiveContainer
     * @param {string} containerId 
     * @param {boolean} [permanent] If true, permanently deletes the container
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public archiveContainer(containerId: string, permanent?: boolean, options?: any) {
        return ContainersApiFp(this.configuration).archiveContainer(containerId, permanent, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Accepts an array of container objects - will attempt to update all of them in a single transaction. If the update fails, none of them will go through.
     * @summary ContainerBatchUpdate
     * @param {Array&lt;BatchUpdateRequest&gt;} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public containerBatchUpdate(body: Array<BatchUpdateRequest>, options?: any) {
        return ContainersApiFp(this.configuration).containerBatchUpdate(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new container object. Containers are the root level object and are considered to contain both the ontology(in form of Metatypes, Metatype Keys, and MetatypeRelationships) as well as the data stored under that ontology.  Endpoint will accept both a single container request object, or an array of container request objects
     * @summary CreateContainer
     * @param {CreateRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public createContainer(body: CreateRequest, options?: any) {
        return ContainersApiFp(this.configuration).createContainer(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * An optional query param `dryrun` may be included with a value of `true` in order to return a HTML formatted string explaining the name and description of the container along with the number of metatypes, metatype relationships, and metatype keys to be created. This request uses a form-data body. If the ontology to be imported is being referenced via url, provide the url via a `path` field. Otherwise a local file may be provided. A file takes precedence over a `path` value if both are provided.
     * @summary ImportContainer
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {boolean} [dataVersioningEnabled] 
     * @param {string} [path] 
     * @param {string} [file] 
     * @param {boolean} [dryrun] If true returns a description of the container that will be created and its contents.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public importContainer(name?: string, description?: string, dataVersioningEnabled?: boolean, path?: string, file?: string, dryrun?: boolean, options?: any) {
        return ContainersApiFp(this.configuration).importContainer(name, description, dataVersioningEnabled, path, file, dryrun, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all containers.
     * @summary ListContainers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public listContainers(options?: any) {
        return ContainersApiFp(this.configuration).listContainers(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Repairs a container's permission set
     * @summary RepairContainerPermissions
     * @param {string} containerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public repairContainerPermissions(containerId: string, options?: any) {
        return ContainersApiFp(this.configuration).repairContainerPermissions(containerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve container by ID.
     * @summary RetrieveContainer
     * @param {string} containerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public retrieveContainer(containerId: string, options?: any) {
        return ContainersApiFp(this.configuration).retrieveContainer(containerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Unarchives a Container. This is the only way to update this value of a container via API.
     * @summary SetContainerActive
     * @param {string} containerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public setContainerActive(containerId: string, options?: any) {
        return ContainersApiFp(this.configuration).setContainerActive(containerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the container. This will fail if a container already exists with the proposed updated name.
     * @summary UpdateContainer
     * @param {UpdateRequest} body 
     * @param {string} containerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public updateContainer(body: UpdateRequest, containerId: string, options?: any) {
        return ContainersApiFp(this.configuration).updateContainer(body, containerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates an existing container via an ontology file.
     * @summary UpdateContainerImport
     * @param {string} containerId 
     * @param {string} [name] 
     * @param {string} [description] 
     * @param {boolean} [dataVersioningEnabled] 
     * @param {string} [path] 
     * @param {string} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public updateContainerImport(containerId: string, name?: string, description?: string, dataVersioningEnabled?: boolean, path?: string, file?: string, options?: any) {
        return ContainersApiFp(this.configuration).updateContainerImport(containerId, name, description, dataVersioningEnabled, path, file, options).then((request) => request(this.axios, this.basePath));
    }
}
