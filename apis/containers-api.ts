/* tslint:disable */
/* eslint-disable */
/**
 * Deep Lynx
 * The construction of megaprojects has consistently demonstrated challenges for project managers in regard to meeting cost, schedule, and performance requirements. Megaproject construction challenges are common place within megaprojects with many active projects in the United States failing to meet cost and schedule efforts by significant margins. Currently, engineering teams operate in siloed tools and disparate teams where connections across design, procurement, and construction systems are translated manually or over brittle point-to-point integrations. The manual nature of data exchange increases the risk of silent errors in the reactor design, with each silent error cascading across the design. These cascading errors lead to uncontrollable risk during construction, resulting in significant delays and cost overruns. Deep Lynx allows for an integrated platform during design and operations of mega projects.  The Deep Lynx Core API delivers a few main features.  1. Provides a set of methods and endpoints for manipulating data in an object oriented database. This allows us to store complex datatypes as records and then to compile them into actual, modifiable objects at run-time. Users can store taxonomies or ontologies in a readable format.  2. Provides methods for storing and retrieving data in a graph database. This data is structured and validated against the aformentioned object oriented database before storage.
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { BatchContainerUpdateRequestInner } from '../models';
import { BatchUpdateContainerResponse } from '../models';
import { ContainerImportResponse } from '../models';
import { ContainerImportUpdateResponse } from '../models';
import { CreateContainerRequest } from '../models';
import { CreateContainerResponse } from '../models';
import { ErrorResponse } from '../models';
import { Generic200Response } from '../models';
import { GetContainerResponse } from '../models';
import { InlineResponse2001 } from '../models';
import { InlineResponse2002 } from '../models';
import { ListContainerResponse } from '../models';
import { UpdateContainerRequest } from '../models';
import { UpdateContainerResponse } from '../models';
/**
 * ContainersApi - axios parameter creator
 * @export
 */
export const ContainersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Post with no body to acknowledge an alert and remove it from the active alerts list.
         * @summary Acknowledge Container Alert
         * @param {string} containerId 
         * @param {string} alertId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acknowledgeContainerAlert: async (containerId: string, alertId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling acknowledgeContainerAlert.');
            }
            // verify required parameter 'alertId' is not null or undefined
            if (alertId === null || alertId === undefined) {
                throw new RequiredError('alertId','Required parameter alertId was null or undefined when calling acknowledgeContainerAlert.');
            }
            const localVarPath = `/containers/{container_id}/alerts/{alert_id}`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"alert_id"}}`, encodeURIComponent(String(alertId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Approves an ontology version
         * @summary Approve Ontology Version
         * @param {string} containerId 
         * @param {string} ontologyVersionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveOntologyVersion: async (containerId: string, ontologyVersionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling approveOntologyVersion.');
            }
            // verify required parameter 'ontologyVersionId' is not null or undefined
            if (ontologyVersionId === null || ontologyVersionId === undefined) {
                throw new RequiredError('ontologyVersionId','Required parameter ontologyVersionId was null or undefined when calling approveOntologyVersion.');
            }
            const localVarPath = `/containers/{container_id}/ontology/versions/{ontology_version_id}/approve`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"ontology_version_id"}}`, encodeURIComponent(String(ontologyVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Archives a Container. This is preferred over deletion as deletion has a cascading effect on the deleted type's keys, relationships, and relationship keys. When in doubt, archive over delete. We'd rather have tombstones than cremating the type.
         * @summary Archive Container
         * @param {string} containerId 
         * @param {boolean} [permanent] If true, permanently deletes the container
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveContainer: async (containerId: string, permanent?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling archiveContainer.');
            }
            const localVarPath = `/containers/{container_id}`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            if (permanent !== undefined) {
                localVarQueryParameter['permanent'] = permanent;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Accepts an array of container objects - will attempt to update all of them in a single transaction. If the update fails, none of them will go through.
         * @summary Container Batch Update
         * @param {Array&lt;BatchContainerUpdateRequestInner&gt;} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerBatchUpdate: async (body: Array<BatchContainerUpdateRequestInner>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling containerBatchUpdate.');
            }
            const localVarPath = `/containers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new container object. Containers are the root level object and are considered to contain both the ontology(in form of Metatypes, Metatype Keys, and MetatypeRelationships) as well as the data stored under that ontology.  Endpoint will accept both a single container request object, or an array of container request objects
         * @summary Create Container
         * @param {CreateContainerRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainer: async (body: CreateContainerRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createContainer.');
            }
            const localVarPath = `/containers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * An optional query param `dryrun` may be included with a value of `true` in order to return a HTML formatted string explaining the name and description of the container along with the number of metatypes, metatype relationships, and metatype keys to be created. This request uses a form-data body. If the ontology to be imported is being referenced via url, provide the url via a `path` field. Otherwise a local file may be provided. A file takes precedence over a `path` value if both are provided.
         * @summary Import Container
         * @param {string} name 
         * @param {string} description 
         * @param {boolean} dataVersioningEnabled 
         * @param {string} path 
         * @param {string} file 
         * @param {boolean} [dryrun] If true returns a description of the container that will be created and its contents.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importContainer: async (name: string, description: string, dataVersioningEnabled: boolean, path: string, file: string, dryrun?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling importContainer.');
            }
            // verify required parameter 'description' is not null or undefined
            if (description === null || description === undefined) {
                throw new RequiredError('description','Required parameter description was null or undefined when calling importContainer.');
            }
            // verify required parameter 'dataVersioningEnabled' is not null or undefined
            if (dataVersioningEnabled === null || dataVersioningEnabled === undefined) {
                throw new RequiredError('dataVersioningEnabled','Required parameter dataVersioningEnabled was null or undefined when calling importContainer.');
            }
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling importContainer.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling importContainer.');
            }
            const localVarPath = `/containers/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication BearerAuth required

            if (dryrun !== undefined) {
                localVarQueryParameter['dryrun'] = dryrun;
            }


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }

            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }

            if (dataVersioningEnabled !== undefined) { 
                localVarFormParams.append('data_versioning_enabled', dataVersioningEnabled as any);
            }

            if (path !== undefined) { 
                localVarFormParams.append('path', path as any);
            }

            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * List all active alerts for a container by ID.
         * @summary List Container Alerts
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerAlerts: async (containerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling listContainerAlerts.');
            }
            const localVarPath = `/containers/{container_id}/alerts`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * List all containers.
         * @summary List Containers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainers: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/containers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all versions of the ontology for a container.
         * @summary List Ontology Versions
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOntologyVersions: async (containerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling listOntologyVersions.');
            }
            const localVarPath = `/containers/{container_id}/ontology/versions`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Publishes an ontology version
         * @summary Publish Ontology Version
         * @param {string} containerId 
         * @param {string} ontologyVersionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishOntologyVersion: async (containerId: string, ontologyVersionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling publishOntologyVersion.');
            }
            // verify required parameter 'ontologyVersionId' is not null or undefined
            if (ontologyVersionId === null || ontologyVersionId === undefined) {
                throw new RequiredError('ontologyVersionId','Required parameter ontologyVersionId was null or undefined when calling publishOntologyVersion.');
            }
            const localVarPath = `/containers/{container_id}/ontology/versions/{ontology_version_id}/publish`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"ontology_version_id"}}`, encodeURIComponent(String(ontologyVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Rejects an ontology version (either in a pending status or after it has been approved).
         * @summary Reject Ontology Version Approval
         * @param {string} containerId 
         * @param {string} ontologyVersionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectOntologyVersionApproval: async (containerId: string, ontologyVersionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling rejectOntologyVersionApproval.');
            }
            // verify required parameter 'ontologyVersionId' is not null or undefined
            if (ontologyVersionId === null || ontologyVersionId === undefined) {
                throw new RequiredError('ontologyVersionId','Required parameter ontologyVersionId was null or undefined when calling rejectOntologyVersionApproval.');
            }
            const localVarPath = `/containers/{container_id}/ontology/versions/{ontology_version_id}/approve`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"ontology_version_id"}}`, encodeURIComponent(String(ontologyVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Repairs a container's permission set
         * @summary Repair Container Permissions
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repairContainerPermissions: async (containerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling repairContainerPermissions.');
            }
            const localVarPath = `/containers/{container_id}/permissions`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve container by ID.
         * @summary Retrieve Container
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveContainer: async (containerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling retrieveContainer.');
            }
            const localVarPath = `/containers/{container_id}`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retreives details on a single ontology version.
         * @summary Retrieve Ontology Version
         * @param {string} containerId 
         * @param {string} versionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveOntologyVersion: async (containerId: string, versionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling retrieveOntologyVersion.');
            }
            // verify required parameter 'versionId' is not null or undefined
            if (versionId === null || versionId === undefined) {
                throw new RequiredError('versionId','Required parameter versionId was null or undefined when calling retrieveOntologyVersion.');
            }
            const localVarPath = `/containers/{container_id}/ontology/versions/{version_id}`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"version_id"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Rolls back the ontology to the selected version.
         * @summary Rollback Ontology Version
         * @param {string} containerId 
         * @param {string} versionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rollbackOntologyVersion: async (containerId: string, versionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling rollbackOntologyVersion.');
            }
            // verify required parameter 'versionId' is not null or undefined
            if (versionId === null || versionId === undefined) {
                throw new RequiredError('versionId','Required parameter versionId was null or undefined when calling rollbackOntologyVersion.');
            }
            const localVarPath = `/containers/{container_id}/ontology/versions/{version_id}/rollback`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"version_id"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Sends an ontology version to be approved by a container admin
         * @summary Send Ontology Version for Approval
         * @param {string} containerId 
         * @param {string} ontologyVersionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendOntologyVersionForApproval: async (containerId: string, ontologyVersionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling sendOntologyVersionForApproval.');
            }
            // verify required parameter 'ontologyVersionId' is not null or undefined
            if (ontologyVersionId === null || ontologyVersionId === undefined) {
                throw new RequiredError('ontologyVersionId','Required parameter ontologyVersionId was null or undefined when calling sendOntologyVersionForApproval.');
            }
            const localVarPath = `/containers/{container_id}/ontology/versions/{ontology_version_id}/approve`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"ontology_version_id"}}`, encodeURIComponent(String(ontologyVersionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Unarchives a Container. This is the only way to update this value of a container via API.
         * @summary Set Container Active
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setContainerActive: async (containerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling setContainerActive.');
            }
            const localVarPath = `/containers/{container_id}/active`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the container. This will fail if a container already exists with the proposed updated name.
         * @summary Update Container
         * @param {UpdateContainerRequest} body 
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContainer: async (body: UpdateContainerRequest, containerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateContainer.');
            }
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling updateContainer.');
            }
            const localVarPath = `/containers/{container_id}`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing container via an ontology file.
         * @summary Update Container Import
         * @param {string} name 
         * @param {string} description 
         * @param {boolean} dataVersioningEnabled 
         * @param {string} path 
         * @param {string} file 
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContainerImport: async (name: string, description: string, dataVersioningEnabled: boolean, path: string, file: string, containerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling updateContainerImport.');
            }
            // verify required parameter 'description' is not null or undefined
            if (description === null || description === undefined) {
                throw new RequiredError('description','Required parameter description was null or undefined when calling updateContainerImport.');
            }
            // verify required parameter 'dataVersioningEnabled' is not null or undefined
            if (dataVersioningEnabled === null || dataVersioningEnabled === undefined) {
                throw new RequiredError('dataVersioningEnabled','Required parameter dataVersioningEnabled was null or undefined when calling updateContainerImport.');
            }
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling updateContainerImport.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling updateContainerImport.');
            }
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling updateContainerImport.');
            }
            const localVarPath = `/containers/import/{container_id}`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication BearerAuth required


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }

            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }

            if (dataVersioningEnabled !== undefined) { 
                localVarFormParams.append('data_versioning_enabled', dataVersioningEnabled as any);
            }

            if (path !== undefined) { 
                localVarFormParams.append('path', path as any);
            }

            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContainersApi - functional programming interface
 * @export
 */
export const ContainersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Post with no body to acknowledge an alert and remove it from the active alerts list.
         * @summary Acknowledge Container Alert
         * @param {string} containerId 
         * @param {string} alertId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acknowledgeContainerAlert(containerId: string, alertId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).acknowledgeContainerAlert(containerId, alertId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Approves an ontology version
         * @summary Approve Ontology Version
         * @param {string} containerId 
         * @param {string} ontologyVersionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approveOntologyVersion(containerId: string, ontologyVersionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).approveOntologyVersion(containerId, ontologyVersionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Archives a Container. This is preferred over deletion as deletion has a cascading effect on the deleted type's keys, relationships, and relationship keys. When in doubt, archive over delete. We'd rather have tombstones than cremating the type.
         * @summary Archive Container
         * @param {string} containerId 
         * @param {boolean} [permanent] If true, permanently deletes the container
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async archiveContainer(containerId: string, permanent?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Generic200Response>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).archiveContainer(containerId, permanent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Accepts an array of container objects - will attempt to update all of them in a single transaction. If the update fails, none of them will go through.
         * @summary Container Batch Update
         * @param {Array&lt;BatchContainerUpdateRequestInner&gt;} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerBatchUpdate(body: Array<BatchContainerUpdateRequestInner>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchUpdateContainerResponse>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).containerBatchUpdate(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a new container object. Containers are the root level object and are considered to contain both the ontology(in form of Metatypes, Metatype Keys, and MetatypeRelationships) as well as the data stored under that ontology.  Endpoint will accept both a single container request object, or an array of container request objects
         * @summary Create Container
         * @param {CreateContainerRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContainer(body: CreateContainerRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateContainerResponse>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).createContainer(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * An optional query param `dryrun` may be included with a value of `true` in order to return a HTML formatted string explaining the name and description of the container along with the number of metatypes, metatype relationships, and metatype keys to be created. This request uses a form-data body. If the ontology to be imported is being referenced via url, provide the url via a `path` field. Otherwise a local file may be provided. A file takes precedence over a `path` value if both are provided.
         * @summary Import Container
         * @param {string} name 
         * @param {string} description 
         * @param {boolean} dataVersioningEnabled 
         * @param {string} path 
         * @param {string} file 
         * @param {boolean} [dryrun] If true returns a description of the container that will be created and its contents.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importContainer(name: string, description: string, dataVersioningEnabled: boolean, path: string, file: string, dryrun?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerImportResponse>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).importContainer(name, description, dataVersioningEnabled, path, file, dryrun, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List all active alerts for a container by ID.
         * @summary List Container Alerts
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContainerAlerts(containerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).listContainerAlerts(containerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List all containers.
         * @summary List Containers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContainers(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListContainerResponse>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).listContainers(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Lists all versions of the ontology for a container.
         * @summary List Ontology Versions
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOntologyVersions(containerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).listOntologyVersions(containerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Publishes an ontology version
         * @summary Publish Ontology Version
         * @param {string} containerId 
         * @param {string} ontologyVersionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async publishOntologyVersion(containerId: string, ontologyVersionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).publishOntologyVersion(containerId, ontologyVersionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Rejects an ontology version (either in a pending status or after it has been approved).
         * @summary Reject Ontology Version Approval
         * @param {string} containerId 
         * @param {string} ontologyVersionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rejectOntologyVersionApproval(containerId: string, ontologyVersionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).rejectOntologyVersionApproval(containerId, ontologyVersionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Repairs a container's permission set
         * @summary Repair Container Permissions
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repairContainerPermissions(containerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Generic200Response>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).repairContainerPermissions(containerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve container by ID.
         * @summary Retrieve Container
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveContainer(containerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetContainerResponse>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).retrieveContainer(containerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retreives details on a single ontology version.
         * @summary Retrieve Ontology Version
         * @param {string} containerId 
         * @param {string} versionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveOntologyVersion(containerId: string, versionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).retrieveOntologyVersion(containerId, versionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Rolls back the ontology to the selected version.
         * @summary Rollback Ontology Version
         * @param {string} containerId 
         * @param {string} versionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rollbackOntologyVersion(containerId: string, versionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).rollbackOntologyVersion(containerId, versionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Sends an ontology version to be approved by a container admin
         * @summary Send Ontology Version for Approval
         * @param {string} containerId 
         * @param {string} ontologyVersionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendOntologyVersionForApproval(containerId: string, ontologyVersionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).sendOntologyVersionForApproval(containerId, ontologyVersionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Unarchives a Container. This is the only way to update this value of a container via API.
         * @summary Set Container Active
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setContainerActive(containerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Generic200Response>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).setContainerActive(containerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates the container. This will fail if a container already exists with the proposed updated name.
         * @summary Update Container
         * @param {UpdateContainerRequest} body 
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateContainer(body: UpdateContainerRequest, containerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateContainerResponse>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).updateContainer(body, containerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates an existing container via an ontology file.
         * @summary Update Container Import
         * @param {string} name 
         * @param {string} description 
         * @param {boolean} dataVersioningEnabled 
         * @param {string} path 
         * @param {string} file 
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateContainerImport(name: string, description: string, dataVersioningEnabled: boolean, path: string, file: string, containerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerImportUpdateResponse>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).updateContainerImport(name, description, dataVersioningEnabled, path, file, containerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ContainersApi - factory interface
 * @export
 */
export const ContainersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Post with no body to acknowledge an alert and remove it from the active alerts list.
         * @summary Acknowledge Container Alert
         * @param {string} containerId 
         * @param {string} alertId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acknowledgeContainerAlert(containerId: string, alertId: string, options?: any): AxiosPromise<void> {
            return ContainersApiFp(configuration).acknowledgeContainerAlert(containerId, alertId, options).then((request) => request(axios, basePath));
        },
        /**
         * Approves an ontology version
         * @summary Approve Ontology Version
         * @param {string} containerId 
         * @param {string} ontologyVersionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveOntologyVersion(containerId: string, ontologyVersionId: string, options?: any): AxiosPromise<void> {
            return ContainersApiFp(configuration).approveOntologyVersion(containerId, ontologyVersionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Archives a Container. This is preferred over deletion as deletion has a cascading effect on the deleted type's keys, relationships, and relationship keys. When in doubt, archive over delete. We'd rather have tombstones than cremating the type.
         * @summary Archive Container
         * @param {string} containerId 
         * @param {boolean} [permanent] If true, permanently deletes the container
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveContainer(containerId: string, permanent?: boolean, options?: any): AxiosPromise<Generic200Response> {
            return ContainersApiFp(configuration).archiveContainer(containerId, permanent, options).then((request) => request(axios, basePath));
        },
        /**
         * Accepts an array of container objects - will attempt to update all of them in a single transaction. If the update fails, none of them will go through.
         * @summary Container Batch Update
         * @param {Array&lt;BatchContainerUpdateRequestInner&gt;} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerBatchUpdate(body: Array<BatchContainerUpdateRequestInner>, options?: any): AxiosPromise<BatchUpdateContainerResponse> {
            return ContainersApiFp(configuration).containerBatchUpdate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new container object. Containers are the root level object and are considered to contain both the ontology(in form of Metatypes, Metatype Keys, and MetatypeRelationships) as well as the data stored under that ontology.  Endpoint will accept both a single container request object, or an array of container request objects
         * @summary Create Container
         * @param {CreateContainerRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainer(body: CreateContainerRequest, options?: any): AxiosPromise<CreateContainerResponse> {
            return ContainersApiFp(configuration).createContainer(body, options).then((request) => request(axios, basePath));
        },
        /**
         * An optional query param `dryrun` may be included with a value of `true` in order to return a HTML formatted string explaining the name and description of the container along with the number of metatypes, metatype relationships, and metatype keys to be created. This request uses a form-data body. If the ontology to be imported is being referenced via url, provide the url via a `path` field. Otherwise a local file may be provided. A file takes precedence over a `path` value if both are provided.
         * @summary Import Container
         * @param {string} name 
         * @param {string} description 
         * @param {boolean} dataVersioningEnabled 
         * @param {string} path 
         * @param {string} file 
         * @param {boolean} [dryrun] If true returns a description of the container that will be created and its contents.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importContainer(name: string, description: string, dataVersioningEnabled: boolean, path: string, file: string, dryrun?: boolean, options?: any): AxiosPromise<ContainerImportResponse> {
            return ContainersApiFp(configuration).importContainer(name, description, dataVersioningEnabled, path, file, dryrun, options).then((request) => request(axios, basePath));
        },
        /**
         * List all active alerts for a container by ID.
         * @summary List Container Alerts
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerAlerts(containerId: string, options?: any): AxiosPromise<void> {
            return ContainersApiFp(configuration).listContainerAlerts(containerId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all containers.
         * @summary List Containers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainers(options?: any): AxiosPromise<ListContainerResponse> {
            return ContainersApiFp(configuration).listContainers(options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all versions of the ontology for a container.
         * @summary List Ontology Versions
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOntologyVersions(containerId: string, options?: any): AxiosPromise<InlineResponse2001> {
            return ContainersApiFp(configuration).listOntologyVersions(containerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Publishes an ontology version
         * @summary Publish Ontology Version
         * @param {string} containerId 
         * @param {string} ontologyVersionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        publishOntologyVersion(containerId: string, ontologyVersionId: string, options?: any): AxiosPromise<void> {
            return ContainersApiFp(configuration).publishOntologyVersion(containerId, ontologyVersionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Rejects an ontology version (either in a pending status or after it has been approved).
         * @summary Reject Ontology Version Approval
         * @param {string} containerId 
         * @param {string} ontologyVersionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rejectOntologyVersionApproval(containerId: string, ontologyVersionId: string, options?: any): AxiosPromise<void> {
            return ContainersApiFp(configuration).rejectOntologyVersionApproval(containerId, ontologyVersionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Repairs a container's permission set
         * @summary Repair Container Permissions
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repairContainerPermissions(containerId: string, options?: any): AxiosPromise<Generic200Response> {
            return ContainersApiFp(configuration).repairContainerPermissions(containerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve container by ID.
         * @summary Retrieve Container
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveContainer(containerId: string, options?: any): AxiosPromise<GetContainerResponse> {
            return ContainersApiFp(configuration).retrieveContainer(containerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retreives details on a single ontology version.
         * @summary Retrieve Ontology Version
         * @param {string} containerId 
         * @param {string} versionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveOntologyVersion(containerId: string, versionId: string, options?: any): AxiosPromise<InlineResponse2002> {
            return ContainersApiFp(configuration).retrieveOntologyVersion(containerId, versionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Rolls back the ontology to the selected version.
         * @summary Rollback Ontology Version
         * @param {string} containerId 
         * @param {string} versionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rollbackOntologyVersion(containerId: string, versionId: string, options?: any): AxiosPromise<void> {
            return ContainersApiFp(configuration).rollbackOntologyVersion(containerId, versionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Sends an ontology version to be approved by a container admin
         * @summary Send Ontology Version for Approval
         * @param {string} containerId 
         * @param {string} ontologyVersionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendOntologyVersionForApproval(containerId: string, ontologyVersionId: string, options?: any): AxiosPromise<void> {
            return ContainersApiFp(configuration).sendOntologyVersionForApproval(containerId, ontologyVersionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Unarchives a Container. This is the only way to update this value of a container via API.
         * @summary Set Container Active
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setContainerActive(containerId: string, options?: any): AxiosPromise<Generic200Response> {
            return ContainersApiFp(configuration).setContainerActive(containerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the container. This will fail if a container already exists with the proposed updated name.
         * @summary Update Container
         * @param {UpdateContainerRequest} body 
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContainer(body: UpdateContainerRequest, containerId: string, options?: any): AxiosPromise<UpdateContainerResponse> {
            return ContainersApiFp(configuration).updateContainer(body, containerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing container via an ontology file.
         * @summary Update Container Import
         * @param {string} name 
         * @param {string} description 
         * @param {boolean} dataVersioningEnabled 
         * @param {string} path 
         * @param {string} file 
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContainerImport(name: string, description: string, dataVersioningEnabled: boolean, path: string, file: string, containerId: string, options?: any): AxiosPromise<ContainerImportUpdateResponse> {
            return ContainersApiFp(configuration).updateContainerImport(name, description, dataVersioningEnabled, path, file, containerId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContainersApi - object-oriented interface
 * @export
 * @class ContainersApi
 * @extends {BaseAPI}
 */
export class ContainersApi extends BaseAPI {
    /**
     * Post with no body to acknowledge an alert and remove it from the active alerts list.
     * @summary Acknowledge Container Alert
     * @param {string} containerId 
     * @param {string} alertId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public acknowledgeContainerAlert(containerId: string, alertId: string, options?: any) {
        return ContainersApiFp(this.configuration).acknowledgeContainerAlert(containerId, alertId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Approves an ontology version
     * @summary Approve Ontology Version
     * @param {string} containerId 
     * @param {string} ontologyVersionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public approveOntologyVersion(containerId: string, ontologyVersionId: string, options?: any) {
        return ContainersApiFp(this.configuration).approveOntologyVersion(containerId, ontologyVersionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Archives a Container. This is preferred over deletion as deletion has a cascading effect on the deleted type's keys, relationships, and relationship keys. When in doubt, archive over delete. We'd rather have tombstones than cremating the type.
     * @summary Archive Container
     * @param {string} containerId 
     * @param {boolean} [permanent] If true, permanently deletes the container
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public archiveContainer(containerId: string, permanent?: boolean, options?: any) {
        return ContainersApiFp(this.configuration).archiveContainer(containerId, permanent, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Accepts an array of container objects - will attempt to update all of them in a single transaction. If the update fails, none of them will go through.
     * @summary Container Batch Update
     * @param {Array&lt;BatchContainerUpdateRequestInner&gt;} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public containerBatchUpdate(body: Array<BatchContainerUpdateRequestInner>, options?: any) {
        return ContainersApiFp(this.configuration).containerBatchUpdate(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new container object. Containers are the root level object and are considered to contain both the ontology(in form of Metatypes, Metatype Keys, and MetatypeRelationships) as well as the data stored under that ontology.  Endpoint will accept both a single container request object, or an array of container request objects
     * @summary Create Container
     * @param {CreateContainerRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public createContainer(body: CreateContainerRequest, options?: any) {
        return ContainersApiFp(this.configuration).createContainer(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * An optional query param `dryrun` may be included with a value of `true` in order to return a HTML formatted string explaining the name and description of the container along with the number of metatypes, metatype relationships, and metatype keys to be created. This request uses a form-data body. If the ontology to be imported is being referenced via url, provide the url via a `path` field. Otherwise a local file may be provided. A file takes precedence over a `path` value if both are provided.
     * @summary Import Container
     * @param {string} name 
     * @param {string} description 
     * @param {boolean} dataVersioningEnabled 
     * @param {string} path 
     * @param {string} file 
     * @param {boolean} [dryrun] If true returns a description of the container that will be created and its contents.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public importContainer(name: string, description: string, dataVersioningEnabled: boolean, path: string, file: string, dryrun?: boolean, options?: any) {
        return ContainersApiFp(this.configuration).importContainer(name, description, dataVersioningEnabled, path, file, dryrun, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all active alerts for a container by ID.
     * @summary List Container Alerts
     * @param {string} containerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public listContainerAlerts(containerId: string, options?: any) {
        return ContainersApiFp(this.configuration).listContainerAlerts(containerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all containers.
     * @summary List Containers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public listContainers(options?: any) {
        return ContainersApiFp(this.configuration).listContainers(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all versions of the ontology for a container.
     * @summary List Ontology Versions
     * @param {string} containerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public listOntologyVersions(containerId: string, options?: any) {
        return ContainersApiFp(this.configuration).listOntologyVersions(containerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Publishes an ontology version
     * @summary Publish Ontology Version
     * @param {string} containerId 
     * @param {string} ontologyVersionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public publishOntologyVersion(containerId: string, ontologyVersionId: string, options?: any) {
        return ContainersApiFp(this.configuration).publishOntologyVersion(containerId, ontologyVersionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Rejects an ontology version (either in a pending status or after it has been approved).
     * @summary Reject Ontology Version Approval
     * @param {string} containerId 
     * @param {string} ontologyVersionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public rejectOntologyVersionApproval(containerId: string, ontologyVersionId: string, options?: any) {
        return ContainersApiFp(this.configuration).rejectOntologyVersionApproval(containerId, ontologyVersionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Repairs a container's permission set
     * @summary Repair Container Permissions
     * @param {string} containerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public repairContainerPermissions(containerId: string, options?: any) {
        return ContainersApiFp(this.configuration).repairContainerPermissions(containerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve container by ID.
     * @summary Retrieve Container
     * @param {string} containerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public retrieveContainer(containerId: string, options?: any) {
        return ContainersApiFp(this.configuration).retrieveContainer(containerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retreives details on a single ontology version.
     * @summary Retrieve Ontology Version
     * @param {string} containerId 
     * @param {string} versionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public retrieveOntologyVersion(containerId: string, versionId: string, options?: any) {
        return ContainersApiFp(this.configuration).retrieveOntologyVersion(containerId, versionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Rolls back the ontology to the selected version.
     * @summary Rollback Ontology Version
     * @param {string} containerId 
     * @param {string} versionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public rollbackOntologyVersion(containerId: string, versionId: string, options?: any) {
        return ContainersApiFp(this.configuration).rollbackOntologyVersion(containerId, versionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sends an ontology version to be approved by a container admin
     * @summary Send Ontology Version for Approval
     * @param {string} containerId 
     * @param {string} ontologyVersionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public sendOntologyVersionForApproval(containerId: string, ontologyVersionId: string, options?: any) {
        return ContainersApiFp(this.configuration).sendOntologyVersionForApproval(containerId, ontologyVersionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Unarchives a Container. This is the only way to update this value of a container via API.
     * @summary Set Container Active
     * @param {string} containerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public setContainerActive(containerId: string, options?: any) {
        return ContainersApiFp(this.configuration).setContainerActive(containerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the container. This will fail if a container already exists with the proposed updated name.
     * @summary Update Container
     * @param {UpdateContainerRequest} body 
     * @param {string} containerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public updateContainer(body: UpdateContainerRequest, containerId: string, options?: any) {
        return ContainersApiFp(this.configuration).updateContainer(body, containerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates an existing container via an ontology file.
     * @summary Update Container Import
     * @param {string} name 
     * @param {string} description 
     * @param {boolean} dataVersioningEnabled 
     * @param {string} path 
     * @param {string} file 
     * @param {string} containerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public updateContainerImport(name: string, description: string, dataVersioningEnabled: boolean, path: string, file: string, containerId: string, options?: any) {
        return ContainersApiFp(this.configuration).updateContainerImport(name, description, dataVersioningEnabled, path, file, containerId, options).then((request) => request(this.axios, this.basePath));
    }
}
