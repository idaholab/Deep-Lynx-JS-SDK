/* tslint:disable */
/* eslint-disable */
/**
 * Deep Lynx
 * The construction of megaprojects has consistently demonstrated challenges for project managers in regard to meeting cost, schedule, and performance requirements. Megaproject construction challenges are common place within megaprojects with many active projects in the United States failing to meet cost and schedule efforts by significant margins. Currently, engineering teams operate in siloed tools and disparate teams where connections across design, procurement, and construction systems are translated manually or over brittle point-to-point integrations. The manual nature of data exchange increases the risk of silent errors in the reactor design, with each silent error cascading across the design. These cascading errors lead to uncontrollable risk during construction, resulting in significant delays and cost overruns. Deep Lynx allows for an integrated platform during design and operations of mega projects.  The Deep Lynx Core API delivers a few main features.  1. Provides a set of methods and endpoints for manipulating data in an object oriented database. This allows us to store complex datatypes as records and then to compile them into actual, modifiable objects at run-time. Users can store taxonomies or ontologies in a readable format.  2. Provides methods for storing and retrieving data in a graph database. This data is structured and validated against the aformentioned object oriented database before storage.
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { BatchContainerUpdateRequestInner } from '../models';
import { BatchUpdateContainerResponse } from '../models';
import { ChangelistsChangelistIdBody } from '../models';
import { ContainerImportResponse } from '../models';
import { ContainerImportUpdateResponse } from '../models';
import { CreateContainerRequest } from '../models';
import { CreateContainerResponse } from '../models';
import { ErrorResponse } from '../models';
import { Generic200Response } from '../models';
import { GetContainerResponse } from '../models';
import { InlineResponse2001 } from '../models';
import { InlineResponse2002 } from '../models';
import { InlineResponse2003 } from '../models';
import { InlineResponse2004 } from '../models';
import { ListChangelistResponse } from '../models';
import { ListContainerResponse } from '../models';
import { OntologyChangelistsBody } from '../models';
import { RetrieveChangelistResponse } from '../models';
import { UpdateContainerRequest } from '../models';
import { UpdateContainerResponse } from '../models';
/**
 * ContainersApi - axios parameter creator
 * @export
 */
export const ContainersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Post with no body to acknowledge an alert and remove it from the active alerts list.
         * @summary Acknowledge Container Alert
         * @param {string} containerId 
         * @param {string} alertId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acknowledgeContainerAlert: async (containerId: string, alertId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling acknowledgeContainerAlert.');
            }
            // verify required parameter 'alertId' is not null or undefined
            if (alertId === null || alertId === undefined) {
                throw new RequiredError('alertId','Required parameter alertId was null or undefined when calling acknowledgeContainerAlert.');
            }
            const localVarPath = `/containers/{container_id}/alerts/{alert_id}`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"alert_id"}}`, encodeURIComponent(String(alertId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Applies changelist to the ontology, creates a new ontology version.
         * @summary Apply Changelist
         * @param {string} containerId 
         * @param {string} changelistID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyChangelist: async (containerId: string, changelistID: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling applyChangelist.');
            }
            // verify required parameter 'changelistID' is not null or undefined
            if (changelistID === null || changelistID === undefined) {
                throw new RequiredError('changelistID','Required parameter changelistID was null or undefined when calling applyChangelist.');
            }
            const localVarPath = `/containers/{container_id}/ontology/changelists/{changelistID}/apply`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"changelistID"}}`, encodeURIComponent(String(changelistID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Approves a changelist
         * @summary Approve Changelist
         * @param {string} containerId 
         * @param {string} changelistId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveChangelist: async (containerId: string, changelistId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling approveChangelist.');
            }
            // verify required parameter 'changelistId' is not null or undefined
            if (changelistId === null || changelistId === undefined) {
                throw new RequiredError('changelistId','Required parameter changelistId was null or undefined when calling approveChangelist.');
            }
            const localVarPath = `/containers/{container_id}/ontology/changelists/{changelist_id}/approve`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"changelist_id"}}`, encodeURIComponent(String(changelistId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Archives a Container. This is preferred over deletion as deletion has a cascading effect on the deleted type's keys, relationships, and relationship keys. When in doubt, archive over delete. We'd rather have tombstones than cremating the type.
         * @summary Archive Container
         * @param {string} containerId 
         * @param {boolean} [permanent] If true, permanently deletes the container
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveContainer: async (containerId: string, permanent?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling archiveContainer.');
            }
            const localVarPath = `/containers/{container_id}`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            if (permanent !== undefined) {
                localVarQueryParameter['permanent'] = permanent;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Accepts an array of container objects - will attempt to update all of them in a single transaction. If the update fails, none of them will go through.
         * @summary Container Batch Update
         * @param {Array&lt;BatchContainerUpdateRequestInner&gt;} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerBatchUpdate: async (body: Array<BatchContainerUpdateRequestInner>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling containerBatchUpdate.');
            }
            const localVarPath = `/containers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new container object. Containers are the root level object and are considered to contain both the ontology(in form of Metatypes, Metatype Keys, and MetatypeRelationships) as well as the data stored under that ontology.  Endpoint will accept both a single container request object, or an array of container request objects
         * @summary Create Container
         * @param {CreateContainerRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainer: async (body: CreateContainerRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createContainer.');
            }
            const localVarPath = `/containers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new changelist.
         * @summary Create New Changelist
         * @param {string} containerId 
         * @param {OntologyChangelistsBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewChangelist: async (containerId: string, body?: OntologyChangelistsBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling createNewChangelist.');
            }
            const localVarPath = `/containers/{container_id}/ontology/changelists`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a changelist
         * @summary Delete Changelist
         * @param {string} containerId 
         * @param {string} changelistId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChangelist: async (containerId: string, changelistId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling deleteChangelist.');
            }
            // verify required parameter 'changelistId' is not null or undefined
            if (changelistId === null || changelistId === undefined) {
                throw new RequiredError('changelistId','Required parameter changelistId was null or undefined when calling deleteChangelist.');
            }
            const localVarPath = `/containers/{container_id}/ontology/changelists/{changelist_id}`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"changelist_id"}}`, encodeURIComponent(String(changelistId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * An optional query param `dryrun` may be included with a value of `true` in order to return a HTML formatted string explaining the name and description of the container along with the number of metatypes, metatype relationships, and metatype keys to be created. This request uses a form-data body. If the ontology to be imported is being referenced via url, provide the url via a `path` field. Otherwise a local file may be provided. A file takes precedence over a `path` value if both are provided.
         * @summary Import Container
         * @param {string} name 
         * @param {string} description 
         * @param {boolean} dataVersioningEnabled 
         * @param {string} path 
         * @param {string} file 
         * @param {boolean} [dryrun] If true returns a description of the container that will be created and its contents.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importContainer: async (name: string, description: string, dataVersioningEnabled: boolean, path: string, file: string, dryrun?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling importContainer.');
            }
            // verify required parameter 'description' is not null or undefined
            if (description === null || description === undefined) {
                throw new RequiredError('description','Required parameter description was null or undefined when calling importContainer.');
            }
            // verify required parameter 'dataVersioningEnabled' is not null or undefined
            if (dataVersioningEnabled === null || dataVersioningEnabled === undefined) {
                throw new RequiredError('dataVersioningEnabled','Required parameter dataVersioningEnabled was null or undefined when calling importContainer.');
            }
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling importContainer.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling importContainer.');
            }
            const localVarPath = `/containers/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication BearerAuth required

            if (dryrun !== undefined) {
                localVarQueryParameter['dryrun'] = dryrun;
            }


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }

            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }

            if (dataVersioningEnabled !== undefined) { 
                localVarFormParams.append('data_versioning_enabled', dataVersioningEnabled as any);
            }

            if (path !== undefined) { 
                localVarFormParams.append('path', path as any);
            }

            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Approves a changelist for application. Note: you must still apply changelist after approval, this does not apply changelist.
         * @summary List Approvals for Changelist
         * @param {string} containerId 
         * @param {string} changelistId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChangelistApprovals: async (containerId: string, changelistId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling listChangelistApprovals.');
            }
            // verify required parameter 'changelistId' is not null or undefined
            if (changelistId === null || changelistId === undefined) {
                throw new RequiredError('changelistId','Required parameter changelistId was null or undefined when calling listChangelistApprovals.');
            }
            const localVarPath = `/containers/{container_id}/ontology/changelists/{changelist_id}/approve`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"changelist_id"}}`, encodeURIComponent(String(changelistId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * List all changelists for a container. Will eventually support filters.
         * @summary List Changelists
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChangelists: async (containerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling listChangelists.');
            }
            const localVarPath = `/containers/{container_id}/ontology/changelists`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * List all active alerts for a container by ID.
         * @summary List Container Alerts
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerAlerts: async (containerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling listContainerAlerts.');
            }
            const localVarPath = `/containers/{container_id}/alerts`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * List all containers.
         * @summary List Containers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainers: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/containers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all versions of the ontology for a container.
         * @summary List Ontology Versions
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOntologyVersions: async (containerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling listOntologyVersions.');
            }
            const localVarPath = `/containers/{container_id}/ontology/versions`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Repairs a container's permission set
         * @summary Repair Container Permissions
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repairContainerPermissions: async (containerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling repairContainerPermissions.');
            }
            const localVarPath = `/containers/{container_id}/permissions`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a changelist by id.
         * @summary Retrieve Changelist
         * @param {string} containerId 
         * @param {string} changelistId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveChangelist: async (containerId: string, changelistId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling retrieveChangelist.');
            }
            // verify required parameter 'changelistId' is not null or undefined
            if (changelistId === null || changelistId === undefined) {
                throw new RequiredError('changelistId','Required parameter changelistId was null or undefined when calling retrieveChangelist.');
            }
            const localVarPath = `/containers/{container_id}/ontology/changelists/{changelist_id}`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"changelist_id"}}`, encodeURIComponent(String(changelistId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve container by ID.
         * @summary Retrieve Container
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveContainer: async (containerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling retrieveContainer.');
            }
            const localVarPath = `/containers/{container_id}`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retreives details on a single ontology version.
         * @summary Retrieve Ontology Version
         * @param {string} containerId 
         * @param {string} versionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveOntologyVersion: async (containerId: string, versionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling retrieveOntologyVersion.');
            }
            // verify required parameter 'versionId' is not null or undefined
            if (versionId === null || versionId === undefined) {
                throw new RequiredError('versionId','Required parameter versionId was null or undefined when calling retrieveOntologyVersion.');
            }
            const localVarPath = `/containers/{container_id}/ontology/versions/{version_id}`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"version_id"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Removes all approvals for changelist.
         * @summary Revoke Changelist Approval
         * @param {string} containerId 
         * @param {string} changelistId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeChangelistApproval: async (containerId: string, changelistId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling revokeChangelistApproval.');
            }
            // verify required parameter 'changelistId' is not null or undefined
            if (changelistId === null || changelistId === undefined) {
                throw new RequiredError('changelistId','Required parameter changelistId was null or undefined when calling revokeChangelistApproval.');
            }
            const localVarPath = `/containers/{container_id}/ontology/changelists/{changelist_id}/approve`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"changelist_id"}}`, encodeURIComponent(String(changelistId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Rolls back the ontology to the selected version.
         * @summary Rollback Ontology Version
         * @param {string} containerId 
         * @param {string} versionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rollbackOntologyVersion: async (containerId: string, versionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling rollbackOntologyVersion.');
            }
            // verify required parameter 'versionId' is not null or undefined
            if (versionId === null || versionId === undefined) {
                throw new RequiredError('versionId','Required parameter versionId was null or undefined when calling rollbackOntologyVersion.');
            }
            const localVarPath = `/containers/{container_id}/ontology/versions/{version_id}/rollback`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"version_id"}}`, encodeURIComponent(String(versionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Unarchives a Container. This is the only way to update this value of a container via API.
         * @summary Set Container Active
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setContainerActive: async (containerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling setContainerActive.');
            }
            const localVarPath = `/containers/{container_id}/active`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a changelist.
         * @summary Update Changelist
         * @param {string} containerId 
         * @param {string} changelistId 
         * @param {ChangelistsChangelistIdBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateChangelist: async (containerId: string, changelistId: string, body?: ChangelistsChangelistIdBody, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling updateChangelist.');
            }
            // verify required parameter 'changelistId' is not null or undefined
            if (changelistId === null || changelistId === undefined) {
                throw new RequiredError('changelistId','Required parameter changelistId was null or undefined when calling updateChangelist.');
            }
            const localVarPath = `/containers/{container_id}/ontology/changelists/{changelist_id}`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"changelist_id"}}`, encodeURIComponent(String(changelistId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the container. This will fail if a container already exists with the proposed updated name.
         * @summary Update Container
         * @param {UpdateContainerRequest} body 
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContainer: async (body: UpdateContainerRequest, containerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateContainer.');
            }
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling updateContainer.');
            }
            const localVarPath = `/containers/{container_id}`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing container via an ontology file.
         * @summary Update Container Import
         * @param {string} name 
         * @param {string} description 
         * @param {boolean} dataVersioningEnabled 
         * @param {string} path 
         * @param {string} file 
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContainerImport: async (name: string, description: string, dataVersioningEnabled: boolean, path: string, file: string, containerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'name' is not null or undefined
            if (name === null || name === undefined) {
                throw new RequiredError('name','Required parameter name was null or undefined when calling updateContainerImport.');
            }
            // verify required parameter 'description' is not null or undefined
            if (description === null || description === undefined) {
                throw new RequiredError('description','Required parameter description was null or undefined when calling updateContainerImport.');
            }
            // verify required parameter 'dataVersioningEnabled' is not null or undefined
            if (dataVersioningEnabled === null || dataVersioningEnabled === undefined) {
                throw new RequiredError('dataVersioningEnabled','Required parameter dataVersioningEnabled was null or undefined when calling updateContainerImport.');
            }
            // verify required parameter 'path' is not null or undefined
            if (path === null || path === undefined) {
                throw new RequiredError('path','Required parameter path was null or undefined when calling updateContainerImport.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling updateContainerImport.');
            }
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling updateContainerImport.');
            }
            const localVarPath = `/containers/import/{container_id}`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication BearerAuth required


            if (name !== undefined) { 
                localVarFormParams.append('name', name as any);
            }

            if (description !== undefined) { 
                localVarFormParams.append('description', description as any);
            }

            if (dataVersioningEnabled !== undefined) { 
                localVarFormParams.append('data_versioning_enabled', dataVersioningEnabled as any);
            }

            if (path !== undefined) { 
                localVarFormParams.append('path', path as any);
            }

            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContainersApi - functional programming interface
 * @export
 */
export const ContainersApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Post with no body to acknowledge an alert and remove it from the active alerts list.
         * @summary Acknowledge Container Alert
         * @param {string} containerId 
         * @param {string} alertId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async acknowledgeContainerAlert(containerId: string, alertId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).acknowledgeContainerAlert(containerId, alertId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Applies changelist to the ontology, creates a new ontology version.
         * @summary Apply Changelist
         * @param {string} containerId 
         * @param {string} changelistID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async applyChangelist(containerId: string, changelistID: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).applyChangelist(containerId, changelistID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Approves a changelist
         * @summary Approve Changelist
         * @param {string} containerId 
         * @param {string} changelistId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async approveChangelist(containerId: string, changelistId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).approveChangelist(containerId, changelistId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Archives a Container. This is preferred over deletion as deletion has a cascading effect on the deleted type's keys, relationships, and relationship keys. When in doubt, archive over delete. We'd rather have tombstones than cremating the type.
         * @summary Archive Container
         * @param {string} containerId 
         * @param {boolean} [permanent] If true, permanently deletes the container
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async archiveContainer(containerId: string, permanent?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Generic200Response>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).archiveContainer(containerId, permanent, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Accepts an array of container objects - will attempt to update all of them in a single transaction. If the update fails, none of them will go through.
         * @summary Container Batch Update
         * @param {Array&lt;BatchContainerUpdateRequestInner&gt;} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerBatchUpdate(body: Array<BatchContainerUpdateRequestInner>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BatchUpdateContainerResponse>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).containerBatchUpdate(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Creates a new container object. Containers are the root level object and are considered to contain both the ontology(in form of Metatypes, Metatype Keys, and MetatypeRelationships) as well as the data stored under that ontology.  Endpoint will accept both a single container request object, or an array of container request objects
         * @summary Create Container
         * @param {CreateContainerRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContainer(body: CreateContainerRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateContainerResponse>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).createContainer(body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a new changelist.
         * @summary Create New Changelist
         * @param {string} containerId 
         * @param {OntologyChangelistsBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNewChangelist(containerId: string, body?: OntologyChangelistsBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).createNewChangelist(containerId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Deletes a changelist
         * @summary Delete Changelist
         * @param {string} containerId 
         * @param {string} changelistId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteChangelist(containerId: string, changelistId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).deleteChangelist(containerId, changelistId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * An optional query param `dryrun` may be included with a value of `true` in order to return a HTML formatted string explaining the name and description of the container along with the number of metatypes, metatype relationships, and metatype keys to be created. This request uses a form-data body. If the ontology to be imported is being referenced via url, provide the url via a `path` field. Otherwise a local file may be provided. A file takes precedence over a `path` value if both are provided.
         * @summary Import Container
         * @param {string} name 
         * @param {string} description 
         * @param {boolean} dataVersioningEnabled 
         * @param {string} path 
         * @param {string} file 
         * @param {boolean} [dryrun] If true returns a description of the container that will be created and its contents.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importContainer(name: string, description: string, dataVersioningEnabled: boolean, path: string, file: string, dryrun?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerImportResponse>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).importContainer(name, description, dataVersioningEnabled, path, file, dryrun, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Approves a changelist for application. Note: you must still apply changelist after approval, this does not apply changelist.
         * @summary List Approvals for Changelist
         * @param {string} containerId 
         * @param {string} changelistId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listChangelistApprovals(containerId: string, changelistId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).listChangelistApprovals(containerId, changelistId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List all changelists for a container. Will eventually support filters.
         * @summary List Changelists
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listChangelists(containerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListChangelistResponse>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).listChangelists(containerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List all active alerts for a container by ID.
         * @summary List Container Alerts
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContainerAlerts(containerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).listContainerAlerts(containerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List all containers.
         * @summary List Containers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listContainers(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListContainerResponse>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).listContainers(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Lists all versions of the ontology for a container.
         * @summary List Ontology Versions
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listOntologyVersions(containerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).listOntologyVersions(containerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Repairs a container's permission set
         * @summary Repair Container Permissions
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async repairContainerPermissions(containerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Generic200Response>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).repairContainerPermissions(containerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a changelist by id.
         * @summary Retrieve Changelist
         * @param {string} containerId 
         * @param {string} changelistId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveChangelist(containerId: string, changelistId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RetrieveChangelistResponse>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).retrieveChangelist(containerId, changelistId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve container by ID.
         * @summary Retrieve Container
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveContainer(containerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetContainerResponse>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).retrieveContainer(containerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retreives details on a single ontology version.
         * @summary Retrieve Ontology Version
         * @param {string} containerId 
         * @param {string} versionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveOntologyVersion(containerId: string, versionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).retrieveOntologyVersion(containerId, versionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Removes all approvals for changelist.
         * @summary Revoke Changelist Approval
         * @param {string} containerId 
         * @param {string} changelistId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async revokeChangelistApproval(containerId: string, changelistId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).revokeChangelistApproval(containerId, changelistId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Rolls back the ontology to the selected version.
         * @summary Rollback Ontology Version
         * @param {string} containerId 
         * @param {string} versionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rollbackOntologyVersion(containerId: string, versionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).rollbackOntologyVersion(containerId, versionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Unarchives a Container. This is the only way to update this value of a container via API.
         * @summary Set Container Active
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setContainerActive(containerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Generic200Response>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).setContainerActive(containerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update a changelist.
         * @summary Update Changelist
         * @param {string} containerId 
         * @param {string} changelistId 
         * @param {ChangelistsChangelistIdBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateChangelist(containerId: string, changelistId: string, body?: ChangelistsChangelistIdBody, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).updateChangelist(containerId, changelistId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates the container. This will fail if a container already exists with the proposed updated name.
         * @summary Update Container
         * @param {UpdateContainerRequest} body 
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateContainer(body: UpdateContainerRequest, containerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateContainerResponse>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).updateContainer(body, containerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates an existing container via an ontology file.
         * @summary Update Container Import
         * @param {string} name 
         * @param {string} description 
         * @param {boolean} dataVersioningEnabled 
         * @param {string} path 
         * @param {string} file 
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateContainerImport(name: string, description: string, dataVersioningEnabled: boolean, path: string, file: string, containerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerImportUpdateResponse>> {
            const localVarAxiosArgs = await ContainersApiAxiosParamCreator(configuration).updateContainerImport(name, description, dataVersioningEnabled, path, file, containerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ContainersApi - factory interface
 * @export
 */
export const ContainersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Post with no body to acknowledge an alert and remove it from the active alerts list.
         * @summary Acknowledge Container Alert
         * @param {string} containerId 
         * @param {string} alertId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        acknowledgeContainerAlert(containerId: string, alertId: string, options?: any): AxiosPromise<void> {
            return ContainersApiFp(configuration).acknowledgeContainerAlert(containerId, alertId, options).then((request) => request(axios, basePath));
        },
        /**
         * Applies changelist to the ontology, creates a new ontology version.
         * @summary Apply Changelist
         * @param {string} containerId 
         * @param {string} changelistID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyChangelist(containerId: string, changelistID: string, options?: any): AxiosPromise<void> {
            return ContainersApiFp(configuration).applyChangelist(containerId, changelistID, options).then((request) => request(axios, basePath));
        },
        /**
         * Approves a changelist
         * @summary Approve Changelist
         * @param {string} containerId 
         * @param {string} changelistId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        approveChangelist(containerId: string, changelistId: string, options?: any): AxiosPromise<void> {
            return ContainersApiFp(configuration).approveChangelist(containerId, changelistId, options).then((request) => request(axios, basePath));
        },
        /**
         * Archives a Container. This is preferred over deletion as deletion has a cascading effect on the deleted type's keys, relationships, and relationship keys. When in doubt, archive over delete. We'd rather have tombstones than cremating the type.
         * @summary Archive Container
         * @param {string} containerId 
         * @param {boolean} [permanent] If true, permanently deletes the container
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveContainer(containerId: string, permanent?: boolean, options?: any): AxiosPromise<Generic200Response> {
            return ContainersApiFp(configuration).archiveContainer(containerId, permanent, options).then((request) => request(axios, basePath));
        },
        /**
         * Accepts an array of container objects - will attempt to update all of them in a single transaction. If the update fails, none of them will go through.
         * @summary Container Batch Update
         * @param {Array&lt;BatchContainerUpdateRequestInner&gt;} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerBatchUpdate(body: Array<BatchContainerUpdateRequestInner>, options?: any): AxiosPromise<BatchUpdateContainerResponse> {
            return ContainersApiFp(configuration).containerBatchUpdate(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new container object. Containers are the root level object and are considered to contain both the ontology(in form of Metatypes, Metatype Keys, and MetatypeRelationships) as well as the data stored under that ontology.  Endpoint will accept both a single container request object, or an array of container request objects
         * @summary Create Container
         * @param {CreateContainerRequest} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContainer(body: CreateContainerRequest, options?: any): AxiosPromise<CreateContainerResponse> {
            return ContainersApiFp(configuration).createContainer(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new changelist.
         * @summary Create New Changelist
         * @param {string} containerId 
         * @param {OntologyChangelistsBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNewChangelist(containerId: string, body?: OntologyChangelistsBody, options?: any): AxiosPromise<InlineResponse2001> {
            return ContainersApiFp(configuration).createNewChangelist(containerId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes a changelist
         * @summary Delete Changelist
         * @param {string} containerId 
         * @param {string} changelistId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteChangelist(containerId: string, changelistId: string, options?: any): AxiosPromise<void> {
            return ContainersApiFp(configuration).deleteChangelist(containerId, changelistId, options).then((request) => request(axios, basePath));
        },
        /**
         * An optional query param `dryrun` may be included with a value of `true` in order to return a HTML formatted string explaining the name and description of the container along with the number of metatypes, metatype relationships, and metatype keys to be created. This request uses a form-data body. If the ontology to be imported is being referenced via url, provide the url via a `path` field. Otherwise a local file may be provided. A file takes precedence over a `path` value if both are provided.
         * @summary Import Container
         * @param {string} name 
         * @param {string} description 
         * @param {boolean} dataVersioningEnabled 
         * @param {string} path 
         * @param {string} file 
         * @param {boolean} [dryrun] If true returns a description of the container that will be created and its contents.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importContainer(name: string, description: string, dataVersioningEnabled: boolean, path: string, file: string, dryrun?: boolean, options?: any): AxiosPromise<ContainerImportResponse> {
            return ContainersApiFp(configuration).importContainer(name, description, dataVersioningEnabled, path, file, dryrun, options).then((request) => request(axios, basePath));
        },
        /**
         * Approves a changelist for application. Note: you must still apply changelist after approval, this does not apply changelist.
         * @summary List Approvals for Changelist
         * @param {string} containerId 
         * @param {string} changelistId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChangelistApprovals(containerId: string, changelistId: string, options?: any): AxiosPromise<InlineResponse2002> {
            return ContainersApiFp(configuration).listChangelistApprovals(containerId, changelistId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all changelists for a container. Will eventually support filters.
         * @summary List Changelists
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChangelists(containerId: string, options?: any): AxiosPromise<ListChangelistResponse> {
            return ContainersApiFp(configuration).listChangelists(containerId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all active alerts for a container by ID.
         * @summary List Container Alerts
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainerAlerts(containerId: string, options?: any): AxiosPromise<void> {
            return ContainersApiFp(configuration).listContainerAlerts(containerId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all containers.
         * @summary List Containers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listContainers(options?: any): AxiosPromise<ListContainerResponse> {
            return ContainersApiFp(configuration).listContainers(options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all versions of the ontology for a container.
         * @summary List Ontology Versions
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listOntologyVersions(containerId: string, options?: any): AxiosPromise<InlineResponse2003> {
            return ContainersApiFp(configuration).listOntologyVersions(containerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Repairs a container's permission set
         * @summary Repair Container Permissions
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        repairContainerPermissions(containerId: string, options?: any): AxiosPromise<Generic200Response> {
            return ContainersApiFp(configuration).repairContainerPermissions(containerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a changelist by id.
         * @summary Retrieve Changelist
         * @param {string} containerId 
         * @param {string} changelistId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveChangelist(containerId: string, changelistId: string, options?: any): AxiosPromise<RetrieveChangelistResponse> {
            return ContainersApiFp(configuration).retrieveChangelist(containerId, changelistId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve container by ID.
         * @summary Retrieve Container
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveContainer(containerId: string, options?: any): AxiosPromise<GetContainerResponse> {
            return ContainersApiFp(configuration).retrieveContainer(containerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retreives details on a single ontology version.
         * @summary Retrieve Ontology Version
         * @param {string} containerId 
         * @param {string} versionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveOntologyVersion(containerId: string, versionId: string, options?: any): AxiosPromise<InlineResponse2004> {
            return ContainersApiFp(configuration).retrieveOntologyVersion(containerId, versionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Removes all approvals for changelist.
         * @summary Revoke Changelist Approval
         * @param {string} containerId 
         * @param {string} changelistId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        revokeChangelistApproval(containerId: string, changelistId: string, options?: any): AxiosPromise<void> {
            return ContainersApiFp(configuration).revokeChangelistApproval(containerId, changelistId, options).then((request) => request(axios, basePath));
        },
        /**
         * Rolls back the ontology to the selected version.
         * @summary Rollback Ontology Version
         * @param {string} containerId 
         * @param {string} versionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rollbackOntologyVersion(containerId: string, versionId: string, options?: any): AxiosPromise<void> {
            return ContainersApiFp(configuration).rollbackOntologyVersion(containerId, versionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Unarchives a Container. This is the only way to update this value of a container via API.
         * @summary Set Container Active
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setContainerActive(containerId: string, options?: any): AxiosPromise<Generic200Response> {
            return ContainersApiFp(configuration).setContainerActive(containerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a changelist.
         * @summary Update Changelist
         * @param {string} containerId 
         * @param {string} changelistId 
         * @param {ChangelistsChangelistIdBody} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateChangelist(containerId: string, changelistId: string, body?: ChangelistsChangelistIdBody, options?: any): AxiosPromise<InlineResponse2001> {
            return ContainersApiFp(configuration).updateChangelist(containerId, changelistId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the container. This will fail if a container already exists with the proposed updated name.
         * @summary Update Container
         * @param {UpdateContainerRequest} body 
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContainer(body: UpdateContainerRequest, containerId: string, options?: any): AxiosPromise<UpdateContainerResponse> {
            return ContainersApiFp(configuration).updateContainer(body, containerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing container via an ontology file.
         * @summary Update Container Import
         * @param {string} name 
         * @param {string} description 
         * @param {boolean} dataVersioningEnabled 
         * @param {string} path 
         * @param {string} file 
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContainerImport(name: string, description: string, dataVersioningEnabled: boolean, path: string, file: string, containerId: string, options?: any): AxiosPromise<ContainerImportUpdateResponse> {
            return ContainersApiFp(configuration).updateContainerImport(name, description, dataVersioningEnabled, path, file, containerId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContainersApi - object-oriented interface
 * @export
 * @class ContainersApi
 * @extends {BaseAPI}
 */
export class ContainersApi extends BaseAPI {
    /**
     * Post with no body to acknowledge an alert and remove it from the active alerts list.
     * @summary Acknowledge Container Alert
     * @param {string} containerId 
     * @param {string} alertId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public acknowledgeContainerAlert(containerId: string, alertId: string, options?: any) {
        return ContainersApiFp(this.configuration).acknowledgeContainerAlert(containerId, alertId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Applies changelist to the ontology, creates a new ontology version.
     * @summary Apply Changelist
     * @param {string} containerId 
     * @param {string} changelistID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public applyChangelist(containerId: string, changelistID: string, options?: any) {
        return ContainersApiFp(this.configuration).applyChangelist(containerId, changelistID, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Approves a changelist
     * @summary Approve Changelist
     * @param {string} containerId 
     * @param {string} changelistId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public approveChangelist(containerId: string, changelistId: string, options?: any) {
        return ContainersApiFp(this.configuration).approveChangelist(containerId, changelistId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Archives a Container. This is preferred over deletion as deletion has a cascading effect on the deleted type's keys, relationships, and relationship keys. When in doubt, archive over delete. We'd rather have tombstones than cremating the type.
     * @summary Archive Container
     * @param {string} containerId 
     * @param {boolean} [permanent] If true, permanently deletes the container
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public archiveContainer(containerId: string, permanent?: boolean, options?: any) {
        return ContainersApiFp(this.configuration).archiveContainer(containerId, permanent, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Accepts an array of container objects - will attempt to update all of them in a single transaction. If the update fails, none of them will go through.
     * @summary Container Batch Update
     * @param {Array&lt;BatchContainerUpdateRequestInner&gt;} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public containerBatchUpdate(body: Array<BatchContainerUpdateRequestInner>, options?: any) {
        return ContainersApiFp(this.configuration).containerBatchUpdate(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new container object. Containers are the root level object and are considered to contain both the ontology(in form of Metatypes, Metatype Keys, and MetatypeRelationships) as well as the data stored under that ontology.  Endpoint will accept both a single container request object, or an array of container request objects
     * @summary Create Container
     * @param {CreateContainerRequest} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public createContainer(body: CreateContainerRequest, options?: any) {
        return ContainersApiFp(this.configuration).createContainer(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new changelist.
     * @summary Create New Changelist
     * @param {string} containerId 
     * @param {OntologyChangelistsBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public createNewChangelist(containerId: string, body?: OntologyChangelistsBody, options?: any) {
        return ContainersApiFp(this.configuration).createNewChangelist(containerId, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes a changelist
     * @summary Delete Changelist
     * @param {string} containerId 
     * @param {string} changelistId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public deleteChangelist(containerId: string, changelistId: string, options?: any) {
        return ContainersApiFp(this.configuration).deleteChangelist(containerId, changelistId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * An optional query param `dryrun` may be included with a value of `true` in order to return a HTML formatted string explaining the name and description of the container along with the number of metatypes, metatype relationships, and metatype keys to be created. This request uses a form-data body. If the ontology to be imported is being referenced via url, provide the url via a `path` field. Otherwise a local file may be provided. A file takes precedence over a `path` value if both are provided.
     * @summary Import Container
     * @param {string} name 
     * @param {string} description 
     * @param {boolean} dataVersioningEnabled 
     * @param {string} path 
     * @param {string} file 
     * @param {boolean} [dryrun] If true returns a description of the container that will be created and its contents.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public importContainer(name: string, description: string, dataVersioningEnabled: boolean, path: string, file: string, dryrun?: boolean, options?: any) {
        return ContainersApiFp(this.configuration).importContainer(name, description, dataVersioningEnabled, path, file, dryrun, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Approves a changelist for application. Note: you must still apply changelist after approval, this does not apply changelist.
     * @summary List Approvals for Changelist
     * @param {string} containerId 
     * @param {string} changelistId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public listChangelistApprovals(containerId: string, changelistId: string, options?: any) {
        return ContainersApiFp(this.configuration).listChangelistApprovals(containerId, changelistId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all changelists for a container. Will eventually support filters.
     * @summary List Changelists
     * @param {string} containerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public listChangelists(containerId: string, options?: any) {
        return ContainersApiFp(this.configuration).listChangelists(containerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all active alerts for a container by ID.
     * @summary List Container Alerts
     * @param {string} containerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public listContainerAlerts(containerId: string, options?: any) {
        return ContainersApiFp(this.configuration).listContainerAlerts(containerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all containers.
     * @summary List Containers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public listContainers(options?: any) {
        return ContainersApiFp(this.configuration).listContainers(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all versions of the ontology for a container.
     * @summary List Ontology Versions
     * @param {string} containerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public listOntologyVersions(containerId: string, options?: any) {
        return ContainersApiFp(this.configuration).listOntologyVersions(containerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Repairs a container's permission set
     * @summary Repair Container Permissions
     * @param {string} containerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public repairContainerPermissions(containerId: string, options?: any) {
        return ContainersApiFp(this.configuration).repairContainerPermissions(containerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve a changelist by id.
     * @summary Retrieve Changelist
     * @param {string} containerId 
     * @param {string} changelistId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public retrieveChangelist(containerId: string, changelistId: string, options?: any) {
        return ContainersApiFp(this.configuration).retrieveChangelist(containerId, changelistId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve container by ID.
     * @summary Retrieve Container
     * @param {string} containerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public retrieveContainer(containerId: string, options?: any) {
        return ContainersApiFp(this.configuration).retrieveContainer(containerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retreives details on a single ontology version.
     * @summary Retrieve Ontology Version
     * @param {string} containerId 
     * @param {string} versionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public retrieveOntologyVersion(containerId: string, versionId: string, options?: any) {
        return ContainersApiFp(this.configuration).retrieveOntologyVersion(containerId, versionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Removes all approvals for changelist.
     * @summary Revoke Changelist Approval
     * @param {string} containerId 
     * @param {string} changelistId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public revokeChangelistApproval(containerId: string, changelistId: string, options?: any) {
        return ContainersApiFp(this.configuration).revokeChangelistApproval(containerId, changelistId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Rolls back the ontology to the selected version.
     * @summary Rollback Ontology Version
     * @param {string} containerId 
     * @param {string} versionId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public rollbackOntologyVersion(containerId: string, versionId: string, options?: any) {
        return ContainersApiFp(this.configuration).rollbackOntologyVersion(containerId, versionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Unarchives a Container. This is the only way to update this value of a container via API.
     * @summary Set Container Active
     * @param {string} containerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public setContainerActive(containerId: string, options?: any) {
        return ContainersApiFp(this.configuration).setContainerActive(containerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a changelist.
     * @summary Update Changelist
     * @param {string} containerId 
     * @param {string} changelistId 
     * @param {ChangelistsChangelistIdBody} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public updateChangelist(containerId: string, changelistId: string, body?: ChangelistsChangelistIdBody, options?: any) {
        return ContainersApiFp(this.configuration).updateChangelist(containerId, changelistId, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates the container. This will fail if a container already exists with the proposed updated name.
     * @summary Update Container
     * @param {UpdateContainerRequest} body 
     * @param {string} containerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public updateContainer(body: UpdateContainerRequest, containerId: string, options?: any) {
        return ContainersApiFp(this.configuration).updateContainer(body, containerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates an existing container via an ontology file.
     * @summary Update Container Import
     * @param {string} name 
     * @param {string} description 
     * @param {boolean} dataVersioningEnabled 
     * @param {string} path 
     * @param {string} file 
     * @param {string} containerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainersApi
     */
    public updateContainerImport(name: string, description: string, dataVersioningEnabled: boolean, path: string, file: string, containerId: string, options?: any) {
        return ContainersApiFp(this.configuration).updateContainerImport(name, description, dataVersioningEnabled, path, file, containerId, options).then((request) => request(this.axios, this.basePath));
    }
}
