/* tslint:disable */
/* eslint-disable */
/**
 * Deep Lynx
 * The construction of megaprojects has consistently demonstrated challenges for project managers in regard to meeting cost, schedule, and performance requirements. Megaproject construction challenges are common place within megaprojects with many active projects in the United States failing to meet cost and schedule efforts by significant margins. Currently, engineering teams operate in siloed tools and disparate teams where connections across design, procurement, and construction systems are translated manually or over brittle point-to-point integrations. The manual nature of data exchange increases the risk of silent errors in the reactor design, with each silent error cascading across the design. These cascading errors lead to uncontrollable risk during construction, resulting in significant delays and cost overruns. Deep Lynx allows for an integrated platform during design and operations of mega projects.  The Deep Lynx Core API delivers a few main features.  1. Provides a set of methods and endpoints for manipulating data in an object oriented database. This allows us to store complex datatypes as records and then to compile them into actual, modifiable objects at run-time. Users can store taxonomies or ontologies in a readable format.  2. Provides methods for storing and retrieving data in a graph database. This data is structured and validated against the aformentioned object oriented database before storage.
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { ContainersFilesResponse } from '../models';
import { ContainersImportDatasourcesImportsResponse } from '../models';
import { ContainersImportDatasourcesImportsResponse1 } from '../models';
import { ContainersImportDatasourcesResponse } from '../models';
import { ContainersImportDatasourcesResponse1 } from '../models';
import { CreateDataSourceRequest } from '../models';
import { Generic200 } from '../models';
import { InlineResponse200 } from '../models';
import { SetConfigurationRequest } from '../models';
/**
 * DataSourcesApi - axios parameter creator
 * @export
 */
export const DataSourcesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Archive a data source, with options to permanently remove it (and associated data).
         * @summary ArchiveDataSource
         * @param {string} containerId 
         * @param {string} dataSourceId 
         * @param {string} [archive] Set to true to archive the data source.
         * @param {string} [forceDelete] Set to true to force deletion of the data source.
         * @param {string} [removeData] Set to true to remove data associated with the data source.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveDataSource: async (containerId: string, dataSourceId: string, archive?: string, forceDelete?: string, removeData?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling archiveDataSource.');
            }
            // verify required parameter 'dataSourceId' is not null or undefined
            if (dataSourceId === null || dataSourceId === undefined) {
                throw new RequiredError('dataSourceId','Required parameter dataSourceId was null or undefined when calling archiveDataSource.');
            }
            const localVarPath = `/containers/{container_id}/import/datasources/{data_source_id}`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required

            if (archive !== undefined) {
                localVarQueryParameter['archive'] = archive;
            }

            if (forceDelete !== undefined) {
                localVarQueryParameter['forceDelete'] = forceDelete;
            }

            if (removeData !== undefined) {
                localVarQueryParameter['removeData'] = removeData;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new datasource. Supported data source types are `http`, `standard` (or `manual`), `jazz`, and `aveva`.
         * @summary CreateDataSource
         * @param {CreateDataSourceRequest} body 
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDataSource: async (body: CreateDataSourceRequest, containerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createDataSource.');
            }
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling createDataSource.');
            }
            const localVarPath = `/containers/{container_id}/import/datasources`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a manual import.
         * @summary CreateManualImport
         * @param {any} body 
         * @param {string} containerId 
         * @param {string} dataSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createManualImport: async (body: any, containerId: string, dataSourceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createManualImport.');
            }
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling createManualImport.');
            }
            // verify required parameter 'dataSourceId' is not null or undefined
            if (dataSourceId === null || dataSourceId === undefined) {
                throw new RequiredError('dataSourceId','Required parameter dataSourceId was null or undefined when calling createManualImport.');
            }
            const localVarPath = `/containers/{container_id}/import/datasources/{data_source_id}/imports`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required

            localVarHeaderParameter['Content-Type'] = 'text/plain';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Downloads a previously uploaded file.
         * @summary DownloadFile
         * @param {string} containerId 
         * @param {string} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile: async (containerId: string, fileId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling downloadFile.');
            }
            // verify required parameter 'fileId' is not null or undefined
            if (fileId === null || fileId === undefined) {
                throw new RequiredError('fileId','Required parameter fileId was null or undefined when calling downloadFile.');
            }
            const localVarPath = `/containers/{container_id}/files/{file_id}/download`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * List the datasources for the container.
         * @summary ListDataSources
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDataSources: async (containerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling listDataSources.');
            }
            const localVarPath = `/containers/{container_id}/import/datasources`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * List the imports for the datasource.
         * @summary ListImportsForDataSource
         * @param {string} containerId 
         * @param {string} dataSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listImportsForDataSource: async (containerId: string, dataSourceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling listImportsForDataSource.');
            }
            // verify required parameter 'dataSourceId' is not null or undefined
            if (dataSourceId === null || dataSourceId === undefined) {
                throw new RequiredError('dataSourceId','Required parameter dataSourceId was null or undefined when calling listImportsForDataSource.');
            }
            const localVarPath = `/containers/{container_id}/import/datasources/{data_source_id}/imports`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single data source by ID.
         * @summary RetrieveDataSource
         * @param {string} containerId 
         * @param {string} dataSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveDataSource: async (containerId: string, dataSourceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling retrieveDataSource.');
            }
            // verify required parameter 'dataSourceId' is not null or undefined
            if (dataSourceId === null || dataSourceId === undefined) {
                throw new RequiredError('dataSourceId','Required parameter dataSourceId was null or undefined when calling retrieveDataSource.');
            }
            const localVarPath = `/containers/{container_id}/import/datasources/{data_source_id}`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about a file by ID.
         * @summary RetrieveFile
         * @param {string} containerId 
         * @param {string} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveFile: async (containerId: string, fileId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling retrieveFile.');
            }
            // verify required parameter 'fileId' is not null or undefined
            if (fileId === null || fileId === undefined) {
                throw new RequiredError('fileId','Required parameter fileId was null or undefined when calling retrieveFile.');
            }
            const localVarPath = `/containers/{container_id}/files/{file_id}`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets a data source active.
         * @summary SetDataSourceActive
         * @param {string} containerId 
         * @param {string} dataSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDataSourceActive: async (containerId: string, dataSourceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling setDataSourceActive.');
            }
            // verify required parameter 'dataSourceId' is not null or undefined
            if (dataSourceId === null || dataSourceId === undefined) {
                throw new RequiredError('dataSourceId','Required parameter dataSourceId was null or undefined when calling setDataSourceActive.');
            }
            const localVarPath = `/containers/{container_id}/import/datasources/{data_source_id}/active`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a data source's configuration in storage. Note that this request body's structure must match that of the data source's adapter type.
         * @summary SetDataSourceConfiguration
         * @param {SetConfigurationRequest} body 
         * @param {string} containerId 
         * @param {string} dataSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDataSourceConfiguration: async (body: SetConfigurationRequest, containerId: string, dataSourceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setDataSourceConfiguration.');
            }
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling setDataSourceConfiguration.');
            }
            // verify required parameter 'dataSourceId' is not null or undefined
            if (dataSourceId === null || dataSourceId === undefined) {
                throw new RequiredError('dataSourceId','Required parameter dataSourceId was null or undefined when calling setDataSourceConfiguration.');
            }
            const localVarPath = `/containers/{container_id}/import/datasources/{data_source_id}`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets a data source inactive.
         * @summary SetDataSourceInactive
         * @param {string} containerId 
         * @param {string} dataSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDataSourceInactive: async (containerId: string, dataSourceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling setDataSourceInactive.');
            }
            // verify required parameter 'dataSourceId' is not null or undefined
            if (dataSourceId === null || dataSourceId === undefined) {
                throw new RequiredError('dataSourceId','Required parameter dataSourceId was null or undefined when calling setDataSourceInactive.');
            }
            const localVarPath = `/containers/{container_id}/import/datasources/{data_source_id}/active`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication httpBearer required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Uploads a file and metadata to Deep Lynx. This endpoint will accept multiple files and multiple metadata properties as form values. If metadata (additional key value pairs) are provided, an import is created for the data source in addition to the file upload. Transformations can be applied to this import to create nodes and edges in the graph with metadata for the uploaded file(s).
         * @summary UploadFile
         * @param {string} containerId 
         * @param {string} dataSourceId 
         * @param {string} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile: async (containerId: string, dataSourceId: string, file?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling uploadFile.');
            }
            // verify required parameter 'dataSourceId' is not null or undefined
            if (dataSourceId === null || dataSourceId === undefined) {
                throw new RequiredError('dataSourceId','Required parameter dataSourceId was null or undefined when calling uploadFile.');
            }
            const localVarPath = `/containers/{container_id}/import/datasources/{data_source_id}/files`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication httpBearer required


            if (file !== undefined) { 
                localVarFormParams.set('file', file as any);
            }
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DataSourcesApi - functional programming interface
 * @export
 */
export const DataSourcesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Archive a data source, with options to permanently remove it (and associated data).
         * @summary ArchiveDataSource
         * @param {string} containerId 
         * @param {string} dataSourceId 
         * @param {string} [archive] Set to true to archive the data source.
         * @param {string} [forceDelete] Set to true to force deletion of the data source.
         * @param {string} [removeData] Set to true to remove data associated with the data source.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async archiveDataSource(containerId: string, dataSourceId: string, archive?: string, forceDelete?: string, removeData?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Generic200>> {
            const localVarAxiosArgs = await DataSourcesApiAxiosParamCreator(configuration).archiveDataSource(containerId, dataSourceId, archive, forceDelete, removeData, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create new datasource. Supported data source types are `http`, `standard` (or `manual`), `jazz`, and `aveva`.
         * @summary CreateDataSource
         * @param {CreateDataSourceRequest} body 
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDataSource(body: CreateDataSourceRequest, containerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainersImportDatasourcesResponse1>> {
            const localVarAxiosArgs = await DataSourcesApiAxiosParamCreator(configuration).createDataSource(body, containerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a manual import.
         * @summary CreateManualImport
         * @param {any} body 
         * @param {string} containerId 
         * @param {string} dataSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createManualImport(body: any, containerId: string, dataSourceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainersImportDatasourcesImportsResponse1>> {
            const localVarAxiosArgs = await DataSourcesApiAxiosParamCreator(configuration).createManualImport(body, containerId, dataSourceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Downloads a previously uploaded file.
         * @summary DownloadFile
         * @param {string} containerId 
         * @param {string} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadFile(containerId: string, fileId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DataSourcesApiAxiosParamCreator(configuration).downloadFile(containerId, fileId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List the datasources for the container.
         * @summary ListDataSources
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDataSources(containerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainersImportDatasourcesResponse>> {
            const localVarAxiosArgs = await DataSourcesApiAxiosParamCreator(configuration).listDataSources(containerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List the imports for the datasource.
         * @summary ListImportsForDataSource
         * @param {string} containerId 
         * @param {string} dataSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listImportsForDataSource(containerId: string, dataSourceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainersImportDatasourcesImportsResponse>> {
            const localVarAxiosArgs = await DataSourcesApiAxiosParamCreator(configuration).listImportsForDataSource(containerId, dataSourceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a single data source by ID.
         * @summary RetrieveDataSource
         * @param {string} containerId 
         * @param {string} dataSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveDataSource(containerId: string, dataSourceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainersImportDatasourcesResponse1>> {
            const localVarAxiosArgs = await DataSourcesApiAxiosParamCreator(configuration).retrieveDataSource(containerId, dataSourceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get information about a file by ID.
         * @summary RetrieveFile
         * @param {string} containerId 
         * @param {string} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveFile(containerId: string, fileId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainersFilesResponse>> {
            const localVarAxiosArgs = await DataSourcesApiAxiosParamCreator(configuration).retrieveFile(containerId, fileId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Sets a data source active.
         * @summary SetDataSourceActive
         * @param {string} containerId 
         * @param {string} dataSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setDataSourceActive(containerId: string, dataSourceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Generic200>> {
            const localVarAxiosArgs = await DataSourcesApiAxiosParamCreator(configuration).setDataSourceActive(containerId, dataSourceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates a data source's configuration in storage. Note that this request body's structure must match that of the data source's adapter type.
         * @summary SetDataSourceConfiguration
         * @param {SetConfigurationRequest} body 
         * @param {string} containerId 
         * @param {string} dataSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setDataSourceConfiguration(body: SetConfigurationRequest, containerId: string, dataSourceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainersImportDatasourcesResponse1>> {
            const localVarAxiosArgs = await DataSourcesApiAxiosParamCreator(configuration).setDataSourceConfiguration(body, containerId, dataSourceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Sets a data source inactive.
         * @summary SetDataSourceInactive
         * @param {string} containerId 
         * @param {string} dataSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setDataSourceInactive(containerId: string, dataSourceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Generic200>> {
            const localVarAxiosArgs = await DataSourcesApiAxiosParamCreator(configuration).setDataSourceInactive(containerId, dataSourceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Uploads a file and metadata to Deep Lynx. This endpoint will accept multiple files and multiple metadata properties as form values. If metadata (additional key value pairs) are provided, an import is created for the data source in addition to the file upload. Transformations can be applied to this import to create nodes and edges in the graph with metadata for the uploaded file(s).
         * @summary UploadFile
         * @param {string} containerId 
         * @param {string} dataSourceId 
         * @param {string} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFile(containerId: string, dataSourceId: string, file?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await DataSourcesApiAxiosParamCreator(configuration).uploadFile(containerId, dataSourceId, file, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DataSourcesApi - factory interface
 * @export
 */
export const DataSourcesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Archive a data source, with options to permanently remove it (and associated data).
         * @summary ArchiveDataSource
         * @param {string} containerId 
         * @param {string} dataSourceId 
         * @param {string} [archive] Set to true to archive the data source.
         * @param {string} [forceDelete] Set to true to force deletion of the data source.
         * @param {string} [removeData] Set to true to remove data associated with the data source.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveDataSource(containerId: string, dataSourceId: string, archive?: string, forceDelete?: string, removeData?: string, options?: any): AxiosPromise<Generic200> {
            return DataSourcesApiFp(configuration).archiveDataSource(containerId, dataSourceId, archive, forceDelete, removeData, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new datasource. Supported data source types are `http`, `standard` (or `manual`), `jazz`, and `aveva`.
         * @summary CreateDataSource
         * @param {CreateDataSourceRequest} body 
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDataSource(body: CreateDataSourceRequest, containerId: string, options?: any): AxiosPromise<ContainersImportDatasourcesResponse1> {
            return DataSourcesApiFp(configuration).createDataSource(body, containerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a manual import.
         * @summary CreateManualImport
         * @param {any} body 
         * @param {string} containerId 
         * @param {string} dataSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createManualImport(body: any, containerId: string, dataSourceId: string, options?: any): AxiosPromise<ContainersImportDatasourcesImportsResponse1> {
            return DataSourcesApiFp(configuration).createManualImport(body, containerId, dataSourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Downloads a previously uploaded file.
         * @summary DownloadFile
         * @param {string} containerId 
         * @param {string} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile(containerId: string, fileId: string, options?: any): AxiosPromise<void> {
            return DataSourcesApiFp(configuration).downloadFile(containerId, fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * List the datasources for the container.
         * @summary ListDataSources
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDataSources(containerId: string, options?: any): AxiosPromise<ContainersImportDatasourcesResponse> {
            return DataSourcesApiFp(configuration).listDataSources(containerId, options).then((request) => request(axios, basePath));
        },
        /**
         * List the imports for the datasource.
         * @summary ListImportsForDataSource
         * @param {string} containerId 
         * @param {string} dataSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listImportsForDataSource(containerId: string, dataSourceId: string, options?: any): AxiosPromise<ContainersImportDatasourcesImportsResponse> {
            return DataSourcesApiFp(configuration).listImportsForDataSource(containerId, dataSourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single data source by ID.
         * @summary RetrieveDataSource
         * @param {string} containerId 
         * @param {string} dataSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveDataSource(containerId: string, dataSourceId: string, options?: any): AxiosPromise<ContainersImportDatasourcesResponse1> {
            return DataSourcesApiFp(configuration).retrieveDataSource(containerId, dataSourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about a file by ID.
         * @summary RetrieveFile
         * @param {string} containerId 
         * @param {string} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveFile(containerId: string, fileId: string, options?: any): AxiosPromise<ContainersFilesResponse> {
            return DataSourcesApiFp(configuration).retrieveFile(containerId, fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets a data source active.
         * @summary SetDataSourceActive
         * @param {string} containerId 
         * @param {string} dataSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDataSourceActive(containerId: string, dataSourceId: string, options?: any): AxiosPromise<Generic200> {
            return DataSourcesApiFp(configuration).setDataSourceActive(containerId, dataSourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a data source's configuration in storage. Note that this request body's structure must match that of the data source's adapter type.
         * @summary SetDataSourceConfiguration
         * @param {SetConfigurationRequest} body 
         * @param {string} containerId 
         * @param {string} dataSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDataSourceConfiguration(body: SetConfigurationRequest, containerId: string, dataSourceId: string, options?: any): AxiosPromise<ContainersImportDatasourcesResponse1> {
            return DataSourcesApiFp(configuration).setDataSourceConfiguration(body, containerId, dataSourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets a data source inactive.
         * @summary SetDataSourceInactive
         * @param {string} containerId 
         * @param {string} dataSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDataSourceInactive(containerId: string, dataSourceId: string, options?: any): AxiosPromise<Generic200> {
            return DataSourcesApiFp(configuration).setDataSourceInactive(containerId, dataSourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Uploads a file and metadata to Deep Lynx. This endpoint will accept multiple files and multiple metadata properties as form values. If metadata (additional key value pairs) are provided, an import is created for the data source in addition to the file upload. Transformations can be applied to this import to create nodes and edges in the graph with metadata for the uploaded file(s).
         * @summary UploadFile
         * @param {string} containerId 
         * @param {string} dataSourceId 
         * @param {string} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(containerId: string, dataSourceId: string, file?: string, options?: any): AxiosPromise<InlineResponse200> {
            return DataSourcesApiFp(configuration).uploadFile(containerId, dataSourceId, file, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DataSourcesApi - object-oriented interface
 * @export
 * @class DataSourcesApi
 * @extends {BaseAPI}
 */
export class DataSourcesApi extends BaseAPI {
    /**
     * Archive a data source, with options to permanently remove it (and associated data).
     * @summary ArchiveDataSource
     * @param {string} containerId 
     * @param {string} dataSourceId 
     * @param {string} [archive] Set to true to archive the data source.
     * @param {string} [forceDelete] Set to true to force deletion of the data source.
     * @param {string} [removeData] Set to true to remove data associated with the data source.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourcesApi
     */
    public archiveDataSource(containerId: string, dataSourceId: string, archive?: string, forceDelete?: string, removeData?: string, options?: any) {
        return DataSourcesApiFp(this.configuration).archiveDataSource(containerId, dataSourceId, archive, forceDelete, removeData, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create new datasource. Supported data source types are `http`, `standard` (or `manual`), `jazz`, and `aveva`.
     * @summary CreateDataSource
     * @param {CreateDataSourceRequest} body 
     * @param {string} containerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourcesApi
     */
    public createDataSource(body: CreateDataSourceRequest, containerId: string, options?: any) {
        return DataSourcesApiFp(this.configuration).createDataSource(body, containerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a manual import.
     * @summary CreateManualImport
     * @param {any} body 
     * @param {string} containerId 
     * @param {string} dataSourceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourcesApi
     */
    public createManualImport(body: any, containerId: string, dataSourceId: string, options?: any) {
        return DataSourcesApiFp(this.configuration).createManualImport(body, containerId, dataSourceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Downloads a previously uploaded file.
     * @summary DownloadFile
     * @param {string} containerId 
     * @param {string} fileId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourcesApi
     */
    public downloadFile(containerId: string, fileId: string, options?: any) {
        return DataSourcesApiFp(this.configuration).downloadFile(containerId, fileId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List the datasources for the container.
     * @summary ListDataSources
     * @param {string} containerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourcesApi
     */
    public listDataSources(containerId: string, options?: any) {
        return DataSourcesApiFp(this.configuration).listDataSources(containerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List the imports for the datasource.
     * @summary ListImportsForDataSource
     * @param {string} containerId 
     * @param {string} dataSourceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourcesApi
     */
    public listImportsForDataSource(containerId: string, dataSourceId: string, options?: any) {
        return DataSourcesApiFp(this.configuration).listImportsForDataSource(containerId, dataSourceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve a single data source by ID.
     * @summary RetrieveDataSource
     * @param {string} containerId 
     * @param {string} dataSourceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourcesApi
     */
    public retrieveDataSource(containerId: string, dataSourceId: string, options?: any) {
        return DataSourcesApiFp(this.configuration).retrieveDataSource(containerId, dataSourceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get information about a file by ID.
     * @summary RetrieveFile
     * @param {string} containerId 
     * @param {string} fileId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourcesApi
     */
    public retrieveFile(containerId: string, fileId: string, options?: any) {
        return DataSourcesApiFp(this.configuration).retrieveFile(containerId, fileId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sets a data source active.
     * @summary SetDataSourceActive
     * @param {string} containerId 
     * @param {string} dataSourceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourcesApi
     */
    public setDataSourceActive(containerId: string, dataSourceId: string, options?: any) {
        return DataSourcesApiFp(this.configuration).setDataSourceActive(containerId, dataSourceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates a data source's configuration in storage. Note that this request body's structure must match that of the data source's adapter type.
     * @summary SetDataSourceConfiguration
     * @param {SetConfigurationRequest} body 
     * @param {string} containerId 
     * @param {string} dataSourceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourcesApi
     */
    public setDataSourceConfiguration(body: SetConfigurationRequest, containerId: string, dataSourceId: string, options?: any) {
        return DataSourcesApiFp(this.configuration).setDataSourceConfiguration(body, containerId, dataSourceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sets a data source inactive.
     * @summary SetDataSourceInactive
     * @param {string} containerId 
     * @param {string} dataSourceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourcesApi
     */
    public setDataSourceInactive(containerId: string, dataSourceId: string, options?: any) {
        return DataSourcesApiFp(this.configuration).setDataSourceInactive(containerId, dataSourceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Uploads a file and metadata to Deep Lynx. This endpoint will accept multiple files and multiple metadata properties as form values. If metadata (additional key value pairs) are provided, an import is created for the data source in addition to the file upload. Transformations can be applied to this import to create nodes and edges in the graph with metadata for the uploaded file(s).
     * @summary UploadFile
     * @param {string} containerId 
     * @param {string} dataSourceId 
     * @param {string} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourcesApi
     */
    public uploadFile(containerId: string, dataSourceId: string, file?: string, options?: any) {
        return DataSourcesApiFp(this.configuration).uploadFile(containerId, dataSourceId, file, options).then((request) => request(this.axios, this.basePath));
    }
}
