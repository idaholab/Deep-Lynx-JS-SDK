/* tslint:disable */
/* eslint-disable */
/**
 * Deep Lynx
 * The construction of megaprojects has consistently demonstrated challenges for project managers in regard to meeting cost, schedule, and performance requirements. Megaproject construction challenges are common place within megaprojects with many active projects in the United States failing to meet cost and schedule efforts by significant margins. Currently, engineering teams operate in siloed tools and disparate teams where connections across design, procurement, and construction systems are translated manually or over brittle point-to-point integrations. The manual nature of data exchange increases the risk of silent errors in the reactor design, with each silent error cascading across the design. These cascading errors lead to uncontrollable risk during construction, resulting in significant delays and cost overruns. Deep Lynx allows for an integrated platform during design and operations of mega projects.  The Deep Lynx Core API delivers a few main features.  1. Provides a set of methods and endpoints for manipulating data in an object oriented database. This allows us to store complex datatypes as records and then to compile them into actual, modifiable objects at run-time. Users can store taxonomies or ontologies in a readable format.  2. Provides methods for storing and retrieving data in a graph database. This data is structured and validated against the aformentioned object oriented database before storage.
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { CreateDataSourceConfig } from '../models';
import { CreateDataSourceRequest } from '../models';
import { CreateDataSourcesResponse } from '../models';
import { CreateManualImportResponse } from '../models';
import { Generic200Response } from '../models';
import { GetDataSourceResponse } from '../models';
import { GetFileInfoResponse } from '../models';
import { ListDataSourceImportsResponse } from '../models';
import { ListDataSourcesResponse } from '../models';
import { UpdateDataSourceResponse } from '../models';
import { UploadFileResponse } from '../models';
/**
 * DataSourcesApi - axios parameter creator
 * @export
 */
export const DataSourcesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Archive a data source, with options to permanently remove it (and associated data).
         * @summary Archive Data Source
         * @param {string} containerId 
         * @param {string} dataSourceId 
         * @param {string} [archive] Set to true to archive the data source.
         * @param {string} [forceDelete] Set to true to force deletion of the data source.
         * @param {string} [removeData] Set to true to remove data associated with the data source.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveDataSource: async (containerId: string, dataSourceId: string, archive?: string, forceDelete?: string, removeData?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling archiveDataSource.');
            }
            // verify required parameter 'dataSourceId' is not null or undefined
            if (dataSourceId === null || dataSourceId === undefined) {
                throw new RequiredError('dataSourceId','Required parameter dataSourceId was null or undefined when calling archiveDataSource.');
            }
            const localVarPath = `/containers/{container_id}/import/datasources/{data_source_id}`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            if (archive !== undefined) {
                localVarQueryParameter['archive'] = archive;
            }

            if (forceDelete !== undefined) {
                localVarQueryParameter['forceDelete'] = forceDelete;
            }

            if (removeData !== undefined) {
                localVarQueryParameter['removeData'] = removeData;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Create new datasource. Supported data source types are `http`, `standard` (or `manual`), `jazz`, and `aveva`.
         * @summary Create Data Source
         * @param {CreateDataSourceRequest} body 
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDataSource: async (body: CreateDataSourceRequest, containerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createDataSource.');
            }
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling createDataSource.');
            }
            const localVarPath = `/containers/{container_id}/import/datasources`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a manual import.
         * @summary Create Manual Import
         * @param {any} body 
         * @param {string} containerId 
         * @param {string} dataSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createManualImport: async (body: any, containerId: string, dataSourceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createManualImport.');
            }
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling createManualImport.');
            }
            // verify required parameter 'dataSourceId' is not null or undefined
            if (dataSourceId === null || dataSourceId === undefined) {
                throw new RequiredError('dataSourceId','Required parameter dataSourceId was null or undefined when calling createManualImport.');
            }
            const localVarPath = `/containers/{container_id}/import/datasources/{data_source_id}/imports`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Downloads a previously uploaded file.
         * @summary Download File
         * @param {string} containerId 
         * @param {string} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile: async (containerId: string, fileId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling downloadFile.');
            }
            // verify required parameter 'fileId' is not null or undefined
            if (fileId === null || fileId === undefined) {
                throw new RequiredError('fileId','Required parameter fileId was null or undefined when calling downloadFile.');
            }
            const localVarPath = `/containers/{container_id}/files/{file_id}/download`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * List the datasources for the container.
         * @summary List Data Sources
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDataSources: async (containerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling listDataSources.');
            }
            const localVarPath = `/containers/{container_id}/import/datasources`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * List the imports for the datasource.
         * @summary List Imports for Data Source
         * @param {string} containerId 
         * @param {string} dataSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listImportsForDataSource: async (containerId: string, dataSourceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling listImportsForDataSource.');
            }
            // verify required parameter 'dataSourceId' is not null or undefined
            if (dataSourceId === null || dataSourceId === undefined) {
                throw new RequiredError('dataSourceId','Required parameter dataSourceId was null or undefined when calling listImportsForDataSource.');
            }
            const localVarPath = `/containers/{container_id}/import/datasources/{data_source_id}/imports`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single data source by ID.
         * @summary Retrieve Data Source
         * @param {string} containerId 
         * @param {string} dataSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveDataSource: async (containerId: string, dataSourceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling retrieveDataSource.');
            }
            // verify required parameter 'dataSourceId' is not null or undefined
            if (dataSourceId === null || dataSourceId === undefined) {
                throw new RequiredError('dataSourceId','Required parameter dataSourceId was null or undefined when calling retrieveDataSource.');
            }
            const localVarPath = `/containers/{container_id}/import/datasources/{data_source_id}`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information about a file by ID.
         * @summary Retrieve File
         * @param {string} containerId 
         * @param {string} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveFile: async (containerId: string, fileId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling retrieveFile.');
            }
            // verify required parameter 'fileId' is not null or undefined
            if (fileId === null || fileId === undefined) {
                throw new RequiredError('fileId','Required parameter fileId was null or undefined when calling retrieveFile.');
            }
            const localVarPath = `/containers/{container_id}/files/{file_id}`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets a data source active.
         * @summary Set Data Source Active
         * @param {string} containerId 
         * @param {string} dataSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDataSourceActive: async (containerId: string, dataSourceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling setDataSourceActive.');
            }
            // verify required parameter 'dataSourceId' is not null or undefined
            if (dataSourceId === null || dataSourceId === undefined) {
                throw new RequiredError('dataSourceId','Required parameter dataSourceId was null or undefined when calling setDataSourceActive.');
            }
            const localVarPath = `/containers/{container_id}/import/datasources/{data_source_id}/active`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates a data source's configuration in storage. Note that this request body's structure must match that of the data source's adapter type.
         * @summary Set Data Source Configuration
         * @param {CreateDataSourceConfig} body 
         * @param {string} containerId 
         * @param {string} dataSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDataSourceConfiguration: async (body: CreateDataSourceConfig, containerId: string, dataSourceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling setDataSourceConfiguration.');
            }
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling setDataSourceConfiguration.');
            }
            // verify required parameter 'dataSourceId' is not null or undefined
            if (dataSourceId === null || dataSourceId === undefined) {
                throw new RequiredError('dataSourceId','Required parameter dataSourceId was null or undefined when calling setDataSourceConfiguration.');
            }
            const localVarPath = `/containers/{container_id}/import/datasources/{data_source_id}`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets a data source inactive.
         * @summary Set Data Source Inactive
         * @param {string} containerId 
         * @param {string} dataSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDataSourceInactive: async (containerId: string, dataSourceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling setDataSourceInactive.');
            }
            // verify required parameter 'dataSourceId' is not null or undefined
            if (dataSourceId === null || dataSourceId === undefined) {
                throw new RequiredError('dataSourceId','Required parameter dataSourceId was null or undefined when calling setDataSourceInactive.');
            }
            const localVarPath = `/containers/{container_id}/import/datasources/{data_source_id}/active`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Uploads a file and it's metadata to Deep Lynx. All additional fields on the multipart form will be processed and added as metadata to the file upload itself.   If you include a file field and call that \"metadata\" - you can include a normal metadata upload as either a json, csv, or xml file. This data will be processed like a normal import and the files attached to the processed data. Once Deep Lynx generates nodes and edges from that data, any files attached will automatically be attached to the resulting nodes/edges as well.  NOTE: The metadata file you upload, if json, must be wrapped in an array. If you do not pass in an array of objects, even if it's a single object, then Deep Lynx will attempt to split up your metadata into its parts instead of treating it like a whole object.
         * @summary Upload File
         * @param {string} containerId 
         * @param {string} dataSourceId 
         * @param {string} [file] 
         * @param {string} [importID] You can attach the metadata to an existing import if desired.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile: async (containerId: string, dataSourceId: string, file?: string, importID?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling uploadFile.');
            }
            // verify required parameter 'dataSourceId' is not null or undefined
            if (dataSourceId === null || dataSourceId === undefined) {
                throw new RequiredError('dataSourceId','Required parameter dataSourceId was null or undefined when calling uploadFile.');
            }
            const localVarPath = `/containers/{container_id}/import/datasources/{data_source_id}/files`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"data_source_id"}}`, encodeURIComponent(String(dataSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new FormData();

            // authentication BearerAuth required

            if (importID !== undefined) {
                localVarQueryParameter['importID'] = importID;
            }


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DataSourcesApi - functional programming interface
 * @export
 */
export const DataSourcesApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Archive a data source, with options to permanently remove it (and associated data).
         * @summary Archive Data Source
         * @param {string} containerId 
         * @param {string} dataSourceId 
         * @param {string} [archive] Set to true to archive the data source.
         * @param {string} [forceDelete] Set to true to force deletion of the data source.
         * @param {string} [removeData] Set to true to remove data associated with the data source.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async archiveDataSource(containerId: string, dataSourceId: string, archive?: string, forceDelete?: string, removeData?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Generic200Response>> {
            const localVarAxiosArgs = await DataSourcesApiAxiosParamCreator(configuration).archiveDataSource(containerId, dataSourceId, archive, forceDelete, removeData, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create new datasource. Supported data source types are `http`, `standard` (or `manual`), `jazz`, and `aveva`.
         * @summary Create Data Source
         * @param {CreateDataSourceRequest} body 
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createDataSource(body: CreateDataSourceRequest, containerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateDataSourcesResponse>> {
            const localVarAxiosArgs = await DataSourcesApiAxiosParamCreator(configuration).createDataSource(body, containerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create a manual import.
         * @summary Create Manual Import
         * @param {any} body 
         * @param {string} containerId 
         * @param {string} dataSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createManualImport(body: any, containerId: string, dataSourceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateManualImportResponse>> {
            const localVarAxiosArgs = await DataSourcesApiAxiosParamCreator(configuration).createManualImport(body, containerId, dataSourceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Downloads a previously uploaded file.
         * @summary Download File
         * @param {string} containerId 
         * @param {string} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadFile(containerId: string, fileId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DataSourcesApiAxiosParamCreator(configuration).downloadFile(containerId, fileId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List the datasources for the container.
         * @summary List Data Sources
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listDataSources(containerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListDataSourcesResponse>> {
            const localVarAxiosArgs = await DataSourcesApiAxiosParamCreator(configuration).listDataSources(containerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List the imports for the datasource.
         * @summary List Imports for Data Source
         * @param {string} containerId 
         * @param {string} dataSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listImportsForDataSource(containerId: string, dataSourceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListDataSourceImportsResponse>> {
            const localVarAxiosArgs = await DataSourcesApiAxiosParamCreator(configuration).listImportsForDataSource(containerId, dataSourceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a single data source by ID.
         * @summary Retrieve Data Source
         * @param {string} containerId 
         * @param {string} dataSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveDataSource(containerId: string, dataSourceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDataSourceResponse>> {
            const localVarAxiosArgs = await DataSourcesApiAxiosParamCreator(configuration).retrieveDataSource(containerId, dataSourceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get information about a file by ID.
         * @summary Retrieve File
         * @param {string} containerId 
         * @param {string} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveFile(containerId: string, fileId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetFileInfoResponse>> {
            const localVarAxiosArgs = await DataSourcesApiAxiosParamCreator(configuration).retrieveFile(containerId, fileId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Sets a data source active.
         * @summary Set Data Source Active
         * @param {string} containerId 
         * @param {string} dataSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setDataSourceActive(containerId: string, dataSourceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Generic200Response>> {
            const localVarAxiosArgs = await DataSourcesApiAxiosParamCreator(configuration).setDataSourceActive(containerId, dataSourceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Updates a data source's configuration in storage. Note that this request body's structure must match that of the data source's adapter type.
         * @summary Set Data Source Configuration
         * @param {CreateDataSourceConfig} body 
         * @param {string} containerId 
         * @param {string} dataSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setDataSourceConfiguration(body: CreateDataSourceConfig, containerId: string, dataSourceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateDataSourceResponse>> {
            const localVarAxiosArgs = await DataSourcesApiAxiosParamCreator(configuration).setDataSourceConfiguration(body, containerId, dataSourceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Sets a data source inactive.
         * @summary Set Data Source Inactive
         * @param {string} containerId 
         * @param {string} dataSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setDataSourceInactive(containerId: string, dataSourceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Generic200Response>> {
            const localVarAxiosArgs = await DataSourcesApiAxiosParamCreator(configuration).setDataSourceInactive(containerId, dataSourceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Uploads a file and it's metadata to Deep Lynx. All additional fields on the multipart form will be processed and added as metadata to the file upload itself.   If you include a file field and call that \"metadata\" - you can include a normal metadata upload as either a json, csv, or xml file. This data will be processed like a normal import and the files attached to the processed data. Once Deep Lynx generates nodes and edges from that data, any files attached will automatically be attached to the resulting nodes/edges as well.  NOTE: The metadata file you upload, if json, must be wrapped in an array. If you do not pass in an array of objects, even if it's a single object, then Deep Lynx will attempt to split up your metadata into its parts instead of treating it like a whole object.
         * @summary Upload File
         * @param {string} containerId 
         * @param {string} dataSourceId 
         * @param {string} [file] 
         * @param {string} [importID] You can attach the metadata to an existing import if desired.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFile(containerId: string, dataSourceId: string, file?: string, importID?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UploadFileResponse>> {
            const localVarAxiosArgs = await DataSourcesApiAxiosParamCreator(configuration).uploadFile(containerId, dataSourceId, file, importID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DataSourcesApi - factory interface
 * @export
 */
export const DataSourcesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Archive a data source, with options to permanently remove it (and associated data).
         * @summary Archive Data Source
         * @param {string} containerId 
         * @param {string} dataSourceId 
         * @param {string} [archive] Set to true to archive the data source.
         * @param {string} [forceDelete] Set to true to force deletion of the data source.
         * @param {string} [removeData] Set to true to remove data associated with the data source.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveDataSource(containerId: string, dataSourceId: string, archive?: string, forceDelete?: string, removeData?: string, options?: any): AxiosPromise<Generic200Response> {
            return DataSourcesApiFp(configuration).archiveDataSource(containerId, dataSourceId, archive, forceDelete, removeData, options).then((request) => request(axios, basePath));
        },
        /**
         * Create new datasource. Supported data source types are `http`, `standard` (or `manual`), `jazz`, and `aveva`.
         * @summary Create Data Source
         * @param {CreateDataSourceRequest} body 
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createDataSource(body: CreateDataSourceRequest, containerId: string, options?: any): AxiosPromise<CreateDataSourcesResponse> {
            return DataSourcesApiFp(configuration).createDataSource(body, containerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a manual import.
         * @summary Create Manual Import
         * @param {any} body 
         * @param {string} containerId 
         * @param {string} dataSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createManualImport(body: any, containerId: string, dataSourceId: string, options?: any): AxiosPromise<CreateManualImportResponse> {
            return DataSourcesApiFp(configuration).createManualImport(body, containerId, dataSourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Downloads a previously uploaded file.
         * @summary Download File
         * @param {string} containerId 
         * @param {string} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadFile(containerId: string, fileId: string, options?: any): AxiosPromise<void> {
            return DataSourcesApiFp(configuration).downloadFile(containerId, fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * List the datasources for the container.
         * @summary List Data Sources
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listDataSources(containerId: string, options?: any): AxiosPromise<ListDataSourcesResponse> {
            return DataSourcesApiFp(configuration).listDataSources(containerId, options).then((request) => request(axios, basePath));
        },
        /**
         * List the imports for the datasource.
         * @summary List Imports for Data Source
         * @param {string} containerId 
         * @param {string} dataSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listImportsForDataSource(containerId: string, dataSourceId: string, options?: any): AxiosPromise<ListDataSourceImportsResponse> {
            return DataSourcesApiFp(configuration).listImportsForDataSource(containerId, dataSourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single data source by ID.
         * @summary Retrieve Data Source
         * @param {string} containerId 
         * @param {string} dataSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveDataSource(containerId: string, dataSourceId: string, options?: any): AxiosPromise<GetDataSourceResponse> {
            return DataSourcesApiFp(configuration).retrieveDataSource(containerId, dataSourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information about a file by ID.
         * @summary Retrieve File
         * @param {string} containerId 
         * @param {string} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveFile(containerId: string, fileId: string, options?: any): AxiosPromise<GetFileInfoResponse> {
            return DataSourcesApiFp(configuration).retrieveFile(containerId, fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets a data source active.
         * @summary Set Data Source Active
         * @param {string} containerId 
         * @param {string} dataSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDataSourceActive(containerId: string, dataSourceId: string, options?: any): AxiosPromise<Generic200Response> {
            return DataSourcesApiFp(configuration).setDataSourceActive(containerId, dataSourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates a data source's configuration in storage. Note that this request body's structure must match that of the data source's adapter type.
         * @summary Set Data Source Configuration
         * @param {CreateDataSourceConfig} body 
         * @param {string} containerId 
         * @param {string} dataSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDataSourceConfiguration(body: CreateDataSourceConfig, containerId: string, dataSourceId: string, options?: any): AxiosPromise<UpdateDataSourceResponse> {
            return DataSourcesApiFp(configuration).setDataSourceConfiguration(body, containerId, dataSourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets a data source inactive.
         * @summary Set Data Source Inactive
         * @param {string} containerId 
         * @param {string} dataSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setDataSourceInactive(containerId: string, dataSourceId: string, options?: any): AxiosPromise<Generic200Response> {
            return DataSourcesApiFp(configuration).setDataSourceInactive(containerId, dataSourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Uploads a file and it's metadata to Deep Lynx. All additional fields on the multipart form will be processed and added as metadata to the file upload itself.   If you include a file field and call that \"metadata\" - you can include a normal metadata upload as either a json, csv, or xml file. This data will be processed like a normal import and the files attached to the processed data. Once Deep Lynx generates nodes and edges from that data, any files attached will automatically be attached to the resulting nodes/edges as well.  NOTE: The metadata file you upload, if json, must be wrapped in an array. If you do not pass in an array of objects, even if it's a single object, then Deep Lynx will attempt to split up your metadata into its parts instead of treating it like a whole object.
         * @summary Upload File
         * @param {string} containerId 
         * @param {string} dataSourceId 
         * @param {string} [file] 
         * @param {string} [importID] You can attach the metadata to an existing import if desired.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(containerId: string, dataSourceId: string, file?: string, importID?: string, options?: any): AxiosPromise<UploadFileResponse> {
            return DataSourcesApiFp(configuration).uploadFile(containerId, dataSourceId, file, importID, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DataSourcesApi - object-oriented interface
 * @export
 * @class DataSourcesApi
 * @extends {BaseAPI}
 */
export class DataSourcesApi extends BaseAPI {
    /**
     * Archive a data source, with options to permanently remove it (and associated data).
     * @summary Archive Data Source
     * @param {string} containerId 
     * @param {string} dataSourceId 
     * @param {string} [archive] Set to true to archive the data source.
     * @param {string} [forceDelete] Set to true to force deletion of the data source.
     * @param {string} [removeData] Set to true to remove data associated with the data source.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourcesApi
     */
    public archiveDataSource(containerId: string, dataSourceId: string, archive?: string, forceDelete?: string, removeData?: string, options?: any) {
        return DataSourcesApiFp(this.configuration).archiveDataSource(containerId, dataSourceId, archive, forceDelete, removeData, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create new datasource. Supported data source types are `http`, `standard` (or `manual`), `jazz`, and `aveva`.
     * @summary Create Data Source
     * @param {CreateDataSourceRequest} body 
     * @param {string} containerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourcesApi
     */
    public createDataSource(body: CreateDataSourceRequest, containerId: string, options?: any) {
        return DataSourcesApiFp(this.configuration).createDataSource(body, containerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a manual import.
     * @summary Create Manual Import
     * @param {any} body 
     * @param {string} containerId 
     * @param {string} dataSourceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourcesApi
     */
    public createManualImport(body: any, containerId: string, dataSourceId: string, options?: any) {
        return DataSourcesApiFp(this.configuration).createManualImport(body, containerId, dataSourceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Downloads a previously uploaded file.
     * @summary Download File
     * @param {string} containerId 
     * @param {string} fileId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourcesApi
     */
    public downloadFile(containerId: string, fileId: string, options?: any) {
        return DataSourcesApiFp(this.configuration).downloadFile(containerId, fileId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List the datasources for the container.
     * @summary List Data Sources
     * @param {string} containerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourcesApi
     */
    public listDataSources(containerId: string, options?: any) {
        return DataSourcesApiFp(this.configuration).listDataSources(containerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List the imports for the datasource.
     * @summary List Imports for Data Source
     * @param {string} containerId 
     * @param {string} dataSourceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourcesApi
     */
    public listImportsForDataSource(containerId: string, dataSourceId: string, options?: any) {
        return DataSourcesApiFp(this.configuration).listImportsForDataSource(containerId, dataSourceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve a single data source by ID.
     * @summary Retrieve Data Source
     * @param {string} containerId 
     * @param {string} dataSourceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourcesApi
     */
    public retrieveDataSource(containerId: string, dataSourceId: string, options?: any) {
        return DataSourcesApiFp(this.configuration).retrieveDataSource(containerId, dataSourceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get information about a file by ID.
     * @summary Retrieve File
     * @param {string} containerId 
     * @param {string} fileId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourcesApi
     */
    public retrieveFile(containerId: string, fileId: string, options?: any) {
        return DataSourcesApiFp(this.configuration).retrieveFile(containerId, fileId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sets a data source active.
     * @summary Set Data Source Active
     * @param {string} containerId 
     * @param {string} dataSourceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourcesApi
     */
    public setDataSourceActive(containerId: string, dataSourceId: string, options?: any) {
        return DataSourcesApiFp(this.configuration).setDataSourceActive(containerId, dataSourceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates a data source's configuration in storage. Note that this request body's structure must match that of the data source's adapter type.
     * @summary Set Data Source Configuration
     * @param {CreateDataSourceConfig} body 
     * @param {string} containerId 
     * @param {string} dataSourceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourcesApi
     */
    public setDataSourceConfiguration(body: CreateDataSourceConfig, containerId: string, dataSourceId: string, options?: any) {
        return DataSourcesApiFp(this.configuration).setDataSourceConfiguration(body, containerId, dataSourceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sets a data source inactive.
     * @summary Set Data Source Inactive
     * @param {string} containerId 
     * @param {string} dataSourceId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourcesApi
     */
    public setDataSourceInactive(containerId: string, dataSourceId: string, options?: any) {
        return DataSourcesApiFp(this.configuration).setDataSourceInactive(containerId, dataSourceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Uploads a file and it's metadata to Deep Lynx. All additional fields on the multipart form will be processed and added as metadata to the file upload itself.   If you include a file field and call that \"metadata\" - you can include a normal metadata upload as either a json, csv, or xml file. This data will be processed like a normal import and the files attached to the processed data. Once Deep Lynx generates nodes and edges from that data, any files attached will automatically be attached to the resulting nodes/edges as well.  NOTE: The metadata file you upload, if json, must be wrapped in an array. If you do not pass in an array of objects, even if it's a single object, then Deep Lynx will attempt to split up your metadata into its parts instead of treating it like a whole object.
     * @summary Upload File
     * @param {string} containerId 
     * @param {string} dataSourceId 
     * @param {string} [file] 
     * @param {string} [importID] You can attach the metadata to an existing import if desired.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DataSourcesApi
     */
    public uploadFile(containerId: string, dataSourceId: string, file?: string, importID?: string, options?: any) {
        return DataSourcesApiFp(this.configuration).uploadFile(containerId, dataSourceId, file, importID, options).then((request) => request(this.axios, this.basePath));
    }
}
