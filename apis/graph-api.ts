/* tslint:disable */
/* eslint-disable */
/**
 * Deep Lynx
 * The construction of megaprojects has consistently demonstrated challenges for project managers in regard to meeting cost, schedule, and performance requirements. Megaproject construction challenges are common place within megaprojects with many active projects in the United States failing to meet cost and schedule efforts by significant margins. Currently, engineering teams operate in siloed tools and disparate teams where connections across design, procurement, and construction systems are translated manually or over brittle point-to-point integrations. The manual nature of data exchange increases the risk of silent errors in the reactor design, with each silent error cascading across the design. These cascading errors lead to uncontrollable risk during construction, resulting in significant delays and cost overruns. Deep Lynx allows for an integrated platform during design and operations of mega projects.  The Deep Lynx Core API delivers a few main features.  1. Provides a set of methods and endpoints for manipulating data in an object oriented database. This allows us to store complex datatypes as records and then to compile them into actual, modifiable objects at run-time. Users can store taxonomies or ontologies in a readable format.  2. Provides methods for storing and retrieving data in a graph database. This data is structured and validated against the aformentioned object oriented database before storage.
 *
 * OpenAPI spec version: 1.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { CreateOrUpdateEdgesRequest } from '../models';
import { CreateOrUpdateNodesRequest } from '../models';
import { Generic200Response } from '../models';
import { GetEdgeResponse } from '../models';
import { GetNodeResponse } from '../models';
import { InlineResponse2001 } from '../models';
import { ListEdgeFiles } from '../models';
import { ListEdgesResponse } from '../models';
import { ListNodeFiles } from '../models';
import { ListNodesByMetatypeResponse } from '../models';
import { ListNodesResponse } from '../models';
/**
 * GraphApi - axios parameter creator
 * @export
 */
export const GraphApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Archives an edge
         * @summary Archive Edge
         * @param {string} containerId 
         * @param {string} edgeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveEdge: async (containerId: string, edgeId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling archiveEdge.');
            }
            // verify required parameter 'edgeId' is not null or undefined
            if (edgeId === null || edgeId === undefined) {
                throw new RequiredError('edgeId','Required parameter edgeId was null or undefined when calling archiveEdge.');
            }
            const localVarPath = `/containers/{container_id}/graphs/edges/{edge_id}`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"edge_id"}}`, encodeURIComponent(String(edgeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Archives a node
         * @summary Archive Node
         * @param {string} containerId 
         * @param {string} nodeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveNode: async (containerId: string, nodeId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling archiveNode.');
            }
            // verify required parameter 'nodeId' is not null or undefined
            if (nodeId === null || nodeId === undefined) {
                throw new RequiredError('nodeId','Required parameter nodeId was null or undefined when calling archiveNode.');
            }
            const localVarPath = `/containers/{container_id}/graphs/nodes/{node_id}`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"node_id"}}`, encodeURIComponent(String(nodeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Attach a file to an edge.
         * @summary Attach Edge File
         * @param {string} containerId 
         * @param {string} fileId 
         * @param {string} edgeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachEdgeFile: async (containerId: string, fileId: string, edgeId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling attachEdgeFile.');
            }
            // verify required parameter 'fileId' is not null or undefined
            if (fileId === null || fileId === undefined) {
                throw new RequiredError('fileId','Required parameter fileId was null or undefined when calling attachEdgeFile.');
            }
            // verify required parameter 'edgeId' is not null or undefined
            if (edgeId === null || edgeId === undefined) {
                throw new RequiredError('edgeId','Required parameter edgeId was null or undefined when calling attachEdgeFile.');
            }
            const localVarPath = `/containers/{container_id}/graphs/edges/{edge_id}/files/{file_id}`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)))
                .replace(`{${"edge_id"}}`, encodeURIComponent(String(edgeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Attach a file to a node.
         * @summary Attach Node File
         * @param {string} containerId 
         * @param {string} nodeId 
         * @param {string} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachNodeFile: async (containerId: string, nodeId: string, fileId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling attachNodeFile.');
            }
            // verify required parameter 'nodeId' is not null or undefined
            if (nodeId === null || nodeId === undefined) {
                throw new RequiredError('nodeId','Required parameter nodeId was null or undefined when calling attachNodeFile.');
            }
            // verify required parameter 'fileId' is not null or undefined
            if (fileId === null || fileId === undefined) {
                throw new RequiredError('fileId','Required parameter fileId was null or undefined when calling attachNodeFile.');
            }
            const localVarPath = `/containers/{container_id}/graphs/nodes/{node_id}/files/{file_id}`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"node_id"}}`, encodeURIComponent(String(nodeId)))
                .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint will attempt to create a connection between two nodes. You can either pass in the node's Deep Lynx IDs, or the node's original id, metatype id, and data source id to create these edges.
         * @summary Create or Update Edges
         * @param {string} containerId 
         * @param {CreateOrUpdateEdgesRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateEdges: async (containerId: string, body?: CreateOrUpdateEdgesRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling createOrUpdateEdges.');
            }
            const localVarPath = `/containers/{container_id}/graphs/edges`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint will either create new nodes or update nodes if one with the same original_id is passed.
         * @summary Create Or Update Nodes
         * @param {CreateOrUpdateNodesRequest} body 
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateNodes: async (body: CreateOrUpdateNodesRequest, containerId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createOrUpdateNodes.');
            }
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling createOrUpdateNodes.');
            }
            const localVarPath = `/containers/{container_id}/graphs/nodes`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            localVarHeaderParameter['Content-Type'] = 'application/json';

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof body !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(body !== undefined ? body : {}) : (body || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Detach file from node
         * @summary Detach Node File
         * @param {string} containerId 
         * @param {string} nodeId 
         * @param {string} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNodeFile: async (containerId: string, nodeId: string, fileId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling deleteNodeFile.');
            }
            // verify required parameter 'nodeId' is not null or undefined
            if (nodeId === null || nodeId === undefined) {
                throw new RequiredError('nodeId','Required parameter nodeId was null or undefined when calling deleteNodeFile.');
            }
            // verify required parameter 'fileId' is not null or undefined
            if (fileId === null || fileId === undefined) {
                throw new RequiredError('fileId','Required parameter fileId was null or undefined when calling deleteNodeFile.');
            }
            const localVarPath = `/containers/{container_id}/graphs/nodes/{node_id}/files/{file_id}`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"node_id"}}`, encodeURIComponent(String(nodeId)))
                .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Detach file from an edge.
         * @summary Detach Node File
         * @param {string} containerId 
         * @param {string} fileId 
         * @param {string} edgeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachNodeFile: async (containerId: string, fileId: string, edgeId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling detachNodeFile.');
            }
            // verify required parameter 'fileId' is not null or undefined
            if (fileId === null || fileId === undefined) {
                throw new RequiredError('fileId','Required parameter fileId was null or undefined when calling detachNodeFile.');
            }
            // verify required parameter 'edgeId' is not null or undefined
            if (edgeId === null || edgeId === undefined) {
                throw new RequiredError('edgeId','Required parameter edgeId was null or undefined when calling detachNodeFile.');
            }
            const localVarPath = `/containers/{container_id}/graphs/edges/{edge_id}/files/{file_id}`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)))
                .replace(`{${"edge_id"}}`, encodeURIComponent(String(edgeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all attached files for edge.
         * @summary List Edge Files
         * @param {string} containerId 
         * @param {string} edgeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEdgeFiles: async (containerId: string, edgeId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling listEdgeFiles.');
            }
            // verify required parameter 'edgeId' is not null or undefined
            if (edgeId === null || edgeId === undefined) {
                throw new RequiredError('edgeId','Required parameter edgeId was null or undefined when calling listEdgeFiles.');
            }
            const localVarPath = `/containers/{container_id}/graphs/edges/{edge_id}/files`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"edge_id"}}`, encodeURIComponent(String(edgeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * List Edges from storage
         * @summary List Edges
         * @param {string} containerId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [originID] 
         * @param {string} [destinationID] 
         * @param {string} [relationshipPairID] 
         * @param {string} [relationshipPairName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEdges: async (containerId: string, limit?: number, offset?: number, originID?: string, destinationID?: string, relationshipPairID?: string, relationshipPairName?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling listEdges.');
            }
            const localVarPath = `/containers/{container_id}/graphs/edges`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (originID !== undefined) {
                localVarQueryParameter['originID'] = originID;
            }

            if (destinationID !== undefined) {
                localVarQueryParameter['destinationID'] = destinationID;
            }

            if (relationshipPairID !== undefined) {
                localVarQueryParameter['relationshipPairID'] = relationshipPairID;
            }

            if (relationshipPairName !== undefined) {
                localVarQueryParameter['relationshipPairName'] = relationshipPairName;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Lists all attached files for node.
         * @summary List Node Files
         * @param {string} containerId 
         * @param {string} nodeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNodeFiles: async (containerId: string, nodeId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling listNodeFiles.');
            }
            // verify required parameter 'nodeId' is not null or undefined
            if (nodeId === null || nodeId === undefined) {
                throw new RequiredError('nodeId','Required parameter nodeId was null or undefined when calling listNodeFiles.');
            }
            const localVarPath = `/containers/{container_id}/graphs/nodes/{node_id}/files`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"node_id"}}`, encodeURIComponent(String(nodeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * List nodes
         * @summary List Nodes
         * @param {string} containerId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [transformationID] Return only nodes for the selected type transformation
         * @param {string} [metatypeID] Return only nodes for the selected metatype
         * @param {string} [dataSourceID] Return only nodes for the selected datasource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNodes: async (containerId: string, limit?: number, offset?: number, transformationID?: string, metatypeID?: string, dataSourceID?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling listNodes.');
            }
            const localVarPath = `/containers/{container_id}/graphs/nodes`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (transformationID !== undefined) {
                localVarQueryParameter['transformationID'] = transformationID;
            }

            if (metatypeID !== undefined) {
                localVarQueryParameter['metatypeID'] = metatypeID;
            }

            if (dataSourceID !== undefined) {
                localVarQueryParameter['dataSourceID'] = dataSourceID;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * List Nodes, filter by MetatypeID
         * @summary List Nodes By Metatype ID
         * @param {string} containerId 
         * @param {string} metatypeId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNodesByMetatypeID: async (containerId: string, metatypeId: string, limit?: number, offset?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling listNodesByMetatypeID.');
            }
            // verify required parameter 'metatypeId' is not null or undefined
            if (metatypeId === null || metatypeId === undefined) {
                throw new RequiredError('metatypeId','Required parameter metatypeId was null or undefined when calling listNodesByMetatypeID.');
            }
            const localVarPath = `/containers/{container_id}/graphs/nodes/metatype/{metatype_id}`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"metatype_id"}}`, encodeURIComponent(String(metatypeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single edge
         * @summary Retrieve Edge
         * @param {string} containerId 
         * @param {string} edgeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveEdge: async (containerId: string, edgeId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling retrieveEdge.');
            }
            // verify required parameter 'edgeId' is not null or undefined
            if (edgeId === null || edgeId === undefined) {
                throw new RequiredError('edgeId','Required parameter edgeId was null or undefined when calling retrieveEdge.');
            }
            const localVarPath = `/containers/{container_id}/graphs/edges/{edge_id}`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"edge_id"}}`, encodeURIComponent(String(edgeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a single node from storage.
         * @summary Retrieve Node
         * @param {string} containerId 
         * @param {string} nodeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveNode: async (containerId: string, nodeId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling retrieveNode.');
            }
            // verify required parameter 'nodeId' is not null or undefined
            if (nodeId === null || nodeId === undefined) {
                throw new RequiredError('nodeId','Required parameter nodeId was null or undefined when calling retrieveNode.');
            }
            const localVarPath = `/containers/{container_id}/graphs/nodes/{node_id}`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"node_id"}}`, encodeURIComponent(String(nodeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve n layers of node-edge relationships given a depth n and an origin node id.
         * @summary Nth Node Query
         * @param {string} containerId 
         * @param {string} nodeId 
         * @param {string} [depth] Number of layers deep to query. Defaults to 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveNthNodes: async (containerId: string, nodeId: string, depth?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling retrieveNthNodes.');
            }
            // verify required parameter 'nodeId' is not null or undefined
            if (nodeId === null || nodeId === undefined) {
                throw new RequiredError('nodeId','Required parameter nodeId was null or undefined when calling retrieveNthNodes.');
            }
            const localVarPath = `/containers/{container_id}/graphs/nodes/{node_id}/graph`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"node_id"}}`, encodeURIComponent(String(nodeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This is an endpoint that accepts a GraphQL query and returns the results of that query. Primarily used for working with time series data on nodes.
         * @summary Timeseries Node Query
         * @param {string} containerId 
         * @param {string} nodeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeseriesNodeQuery: async (containerId: string, nodeId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'containerId' is not null or undefined
            if (containerId === null || containerId === undefined) {
                throw new RequiredError('containerId','Required parameter containerId was null or undefined when calling timeseriesNodeQuery.');
            }
            // verify required parameter 'nodeId' is not null or undefined
            if (nodeId === null || nodeId === undefined) {
                throw new RequiredError('nodeId','Required parameter nodeId was null or undefined when calling timeseriesNodeQuery.');
            }
            const localVarPath = `/containers/{container_id}/graphs/nodes/{node_id}/timeseries`
                .replace(`{${"container_id"}}`, encodeURIComponent(String(containerId)))
                .replace(`{${"node_id"}}`, encodeURIComponent(String(nodeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                query.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GraphApi - functional programming interface
 * @export
 */
export const GraphApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Archives an edge
         * @summary Archive Edge
         * @param {string} containerId 
         * @param {string} edgeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async archiveEdge(containerId: string, edgeId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Generic200Response>> {
            const localVarAxiosArgs = await GraphApiAxiosParamCreator(configuration).archiveEdge(containerId, edgeId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Archives a node
         * @summary Archive Node
         * @param {string} containerId 
         * @param {string} nodeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async archiveNode(containerId: string, nodeId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Generic200Response>> {
            const localVarAxiosArgs = await GraphApiAxiosParamCreator(configuration).archiveNode(containerId, nodeId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Attach a file to an edge.
         * @summary Attach Edge File
         * @param {string} containerId 
         * @param {string} fileId 
         * @param {string} edgeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async attachEdgeFile(containerId: string, fileId: string, edgeId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Generic200Response>> {
            const localVarAxiosArgs = await GraphApiAxiosParamCreator(configuration).attachEdgeFile(containerId, fileId, edgeId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Attach a file to a node.
         * @summary Attach Node File
         * @param {string} containerId 
         * @param {string} nodeId 
         * @param {string} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async attachNodeFile(containerId: string, nodeId: string, fileId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Generic200Response>> {
            const localVarAxiosArgs = await GraphApiAxiosParamCreator(configuration).attachNodeFile(containerId, nodeId, fileId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This endpoint will attempt to create a connection between two nodes. You can either pass in the node's Deep Lynx IDs, or the node's original id, metatype id, and data source id to create these edges.
         * @summary Create or Update Edges
         * @param {string} containerId 
         * @param {CreateOrUpdateEdgesRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrUpdateEdges(containerId: string, body?: CreateOrUpdateEdgesRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Generic200Response>> {
            const localVarAxiosArgs = await GraphApiAxiosParamCreator(configuration).createOrUpdateEdges(containerId, body, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This endpoint will either create new nodes or update nodes if one with the same original_id is passed.
         * @summary Create Or Update Nodes
         * @param {CreateOrUpdateNodesRequest} body 
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrUpdateNodes(body: CreateOrUpdateNodesRequest, containerId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Generic200Response>> {
            const localVarAxiosArgs = await GraphApiAxiosParamCreator(configuration).createOrUpdateNodes(body, containerId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Detach file from node
         * @summary Detach Node File
         * @param {string} containerId 
         * @param {string} nodeId 
         * @param {string} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNodeFile(containerId: string, nodeId: string, fileId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Generic200Response>> {
            const localVarAxiosArgs = await GraphApiAxiosParamCreator(configuration).deleteNodeFile(containerId, nodeId, fileId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Detach file from an edge.
         * @summary Detach Node File
         * @param {string} containerId 
         * @param {string} fileId 
         * @param {string} edgeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async detachNodeFile(containerId: string, fileId: string, edgeId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Generic200Response>> {
            const localVarAxiosArgs = await GraphApiAxiosParamCreator(configuration).detachNodeFile(containerId, fileId, edgeId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Lists all attached files for edge.
         * @summary List Edge Files
         * @param {string} containerId 
         * @param {string} edgeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEdgeFiles(containerId: string, edgeId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListEdgeFiles>> {
            const localVarAxiosArgs = await GraphApiAxiosParamCreator(configuration).listEdgeFiles(containerId, edgeId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List Edges from storage
         * @summary List Edges
         * @param {string} containerId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [originID] 
         * @param {string} [destinationID] 
         * @param {string} [relationshipPairID] 
         * @param {string} [relationshipPairName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listEdges(containerId: string, limit?: number, offset?: number, originID?: string, destinationID?: string, relationshipPairID?: string, relationshipPairName?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListEdgesResponse>> {
            const localVarAxiosArgs = await GraphApiAxiosParamCreator(configuration).listEdges(containerId, limit, offset, originID, destinationID, relationshipPairID, relationshipPairName, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Lists all attached files for node.
         * @summary List Node Files
         * @param {string} containerId 
         * @param {string} nodeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNodeFiles(containerId: string, nodeId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListNodeFiles>> {
            const localVarAxiosArgs = await GraphApiAxiosParamCreator(configuration).listNodeFiles(containerId, nodeId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List nodes
         * @summary List Nodes
         * @param {string} containerId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [transformationID] Return only nodes for the selected type transformation
         * @param {string} [metatypeID] Return only nodes for the selected metatype
         * @param {string} [dataSourceID] Return only nodes for the selected datasource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNodes(containerId: string, limit?: number, offset?: number, transformationID?: string, metatypeID?: string, dataSourceID?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListNodesResponse>> {
            const localVarAxiosArgs = await GraphApiAxiosParamCreator(configuration).listNodes(containerId, limit, offset, transformationID, metatypeID, dataSourceID, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List Nodes, filter by MetatypeID
         * @summary List Nodes By Metatype ID
         * @param {string} containerId 
         * @param {string} metatypeId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listNodesByMetatypeID(containerId: string, metatypeId: string, limit?: number, offset?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListNodesByMetatypeResponse>> {
            const localVarAxiosArgs = await GraphApiAxiosParamCreator(configuration).listNodesByMetatypeID(containerId, metatypeId, limit, offset, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a single edge
         * @summary Retrieve Edge
         * @param {string} containerId 
         * @param {string} edgeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveEdge(containerId: string, edgeId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetEdgeResponse>> {
            const localVarAxiosArgs = await GraphApiAxiosParamCreator(configuration).retrieveEdge(containerId, edgeId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve a single node from storage.
         * @summary Retrieve Node
         * @param {string} containerId 
         * @param {string} nodeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveNode(containerId: string, nodeId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetNodeResponse>> {
            const localVarAxiosArgs = await GraphApiAxiosParamCreator(configuration).retrieveNode(containerId, nodeId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Retrieve n layers of node-edge relationships given a depth n and an origin node id.
         * @summary Nth Node Query
         * @param {string} containerId 
         * @param {string} nodeId 
         * @param {string} [depth] Number of layers deep to query. Defaults to 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveNthNodes(containerId: string, nodeId: string, depth?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await GraphApiAxiosParamCreator(configuration).retrieveNthNodes(containerId, nodeId, depth, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This is an endpoint that accepts a GraphQL query and returns the results of that query. Primarily used for working with time series data on nodes.
         * @summary Timeseries Node Query
         * @param {string} containerId 
         * @param {string} nodeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async timeseriesNodeQuery(containerId: string, nodeId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await GraphApiAxiosParamCreator(configuration).timeseriesNodeQuery(containerId, nodeId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * GraphApi - factory interface
 * @export
 */
export const GraphApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Archives an edge
         * @summary Archive Edge
         * @param {string} containerId 
         * @param {string} edgeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveEdge(containerId: string, edgeId: string, options?: any): AxiosPromise<Generic200Response> {
            return GraphApiFp(configuration).archiveEdge(containerId, edgeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Archives a node
         * @summary Archive Node
         * @param {string} containerId 
         * @param {string} nodeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        archiveNode(containerId: string, nodeId: string, options?: any): AxiosPromise<Generic200Response> {
            return GraphApiFp(configuration).archiveNode(containerId, nodeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Attach a file to an edge.
         * @summary Attach Edge File
         * @param {string} containerId 
         * @param {string} fileId 
         * @param {string} edgeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachEdgeFile(containerId: string, fileId: string, edgeId: string, options?: any): AxiosPromise<Generic200Response> {
            return GraphApiFp(configuration).attachEdgeFile(containerId, fileId, edgeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Attach a file to a node.
         * @summary Attach Node File
         * @param {string} containerId 
         * @param {string} nodeId 
         * @param {string} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        attachNodeFile(containerId: string, nodeId: string, fileId: string, options?: any): AxiosPromise<Generic200Response> {
            return GraphApiFp(configuration).attachNodeFile(containerId, nodeId, fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will attempt to create a connection between two nodes. You can either pass in the node's Deep Lynx IDs, or the node's original id, metatype id, and data source id to create these edges.
         * @summary Create or Update Edges
         * @param {string} containerId 
         * @param {CreateOrUpdateEdgesRequest} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateEdges(containerId: string, body?: CreateOrUpdateEdgesRequest, options?: any): AxiosPromise<Generic200Response> {
            return GraphApiFp(configuration).createOrUpdateEdges(containerId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint will either create new nodes or update nodes if one with the same original_id is passed.
         * @summary Create Or Update Nodes
         * @param {CreateOrUpdateNodesRequest} body 
         * @param {string} containerId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrUpdateNodes(body: CreateOrUpdateNodesRequest, containerId: string, options?: any): AxiosPromise<Generic200Response> {
            return GraphApiFp(configuration).createOrUpdateNodes(body, containerId, options).then((request) => request(axios, basePath));
        },
        /**
         * Detach file from node
         * @summary Detach Node File
         * @param {string} containerId 
         * @param {string} nodeId 
         * @param {string} fileId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNodeFile(containerId: string, nodeId: string, fileId: string, options?: any): AxiosPromise<Generic200Response> {
            return GraphApiFp(configuration).deleteNodeFile(containerId, nodeId, fileId, options).then((request) => request(axios, basePath));
        },
        /**
         * Detach file from an edge.
         * @summary Detach Node File
         * @param {string} containerId 
         * @param {string} fileId 
         * @param {string} edgeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        detachNodeFile(containerId: string, fileId: string, edgeId: string, options?: any): AxiosPromise<Generic200Response> {
            return GraphApiFp(configuration).detachNodeFile(containerId, fileId, edgeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all attached files for edge.
         * @summary List Edge Files
         * @param {string} containerId 
         * @param {string} edgeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEdgeFiles(containerId: string, edgeId: string, options?: any): AxiosPromise<ListEdgeFiles> {
            return GraphApiFp(configuration).listEdgeFiles(containerId, edgeId, options).then((request) => request(axios, basePath));
        },
        /**
         * List Edges from storage
         * @summary List Edges
         * @param {string} containerId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [originID] 
         * @param {string} [destinationID] 
         * @param {string} [relationshipPairID] 
         * @param {string} [relationshipPairName] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listEdges(containerId: string, limit?: number, offset?: number, originID?: string, destinationID?: string, relationshipPairID?: string, relationshipPairName?: string, options?: any): AxiosPromise<ListEdgesResponse> {
            return GraphApiFp(configuration).listEdges(containerId, limit, offset, originID, destinationID, relationshipPairID, relationshipPairName, options).then((request) => request(axios, basePath));
        },
        /**
         * Lists all attached files for node.
         * @summary List Node Files
         * @param {string} containerId 
         * @param {string} nodeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNodeFiles(containerId: string, nodeId: string, options?: any): AxiosPromise<ListNodeFiles> {
            return GraphApiFp(configuration).listNodeFiles(containerId, nodeId, options).then((request) => request(axios, basePath));
        },
        /**
         * List nodes
         * @summary List Nodes
         * @param {string} containerId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {string} [transformationID] Return only nodes for the selected type transformation
         * @param {string} [metatypeID] Return only nodes for the selected metatype
         * @param {string} [dataSourceID] Return only nodes for the selected datasource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNodes(containerId: string, limit?: number, offset?: number, transformationID?: string, metatypeID?: string, dataSourceID?: string, options?: any): AxiosPromise<ListNodesResponse> {
            return GraphApiFp(configuration).listNodes(containerId, limit, offset, transformationID, metatypeID, dataSourceID, options).then((request) => request(axios, basePath));
        },
        /**
         * List Nodes, filter by MetatypeID
         * @summary List Nodes By Metatype ID
         * @param {string} containerId 
         * @param {string} metatypeId 
         * @param {number} [limit] 
         * @param {number} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listNodesByMetatypeID(containerId: string, metatypeId: string, limit?: number, offset?: number, options?: any): AxiosPromise<ListNodesByMetatypeResponse> {
            return GraphApiFp(configuration).listNodesByMetatypeID(containerId, metatypeId, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single edge
         * @summary Retrieve Edge
         * @param {string} containerId 
         * @param {string} edgeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveEdge(containerId: string, edgeId: string, options?: any): AxiosPromise<GetEdgeResponse> {
            return GraphApiFp(configuration).retrieveEdge(containerId, edgeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a single node from storage.
         * @summary Retrieve Node
         * @param {string} containerId 
         * @param {string} nodeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveNode(containerId: string, nodeId: string, options?: any): AxiosPromise<GetNodeResponse> {
            return GraphApiFp(configuration).retrieveNode(containerId, nodeId, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve n layers of node-edge relationships given a depth n and an origin node id.
         * @summary Nth Node Query
         * @param {string} containerId 
         * @param {string} nodeId 
         * @param {string} [depth] Number of layers deep to query. Defaults to 10.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveNthNodes(containerId: string, nodeId: string, depth?: string, options?: any): AxiosPromise<InlineResponse2001> {
            return GraphApiFp(configuration).retrieveNthNodes(containerId, nodeId, depth, options).then((request) => request(axios, basePath));
        },
        /**
         * This is an endpoint that accepts a GraphQL query and returns the results of that query. Primarily used for working with time series data on nodes.
         * @summary Timeseries Node Query
         * @param {string} containerId 
         * @param {string} nodeId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        timeseriesNodeQuery(containerId: string, nodeId: string, options?: any): AxiosPromise<void> {
            return GraphApiFp(configuration).timeseriesNodeQuery(containerId, nodeId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GraphApi - object-oriented interface
 * @export
 * @class GraphApi
 * @extends {BaseAPI}
 */
export class GraphApi extends BaseAPI {
    /**
     * Archives an edge
     * @summary Archive Edge
     * @param {string} containerId 
     * @param {string} edgeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public archiveEdge(containerId: string, edgeId: string, options?: any) {
        return GraphApiFp(this.configuration).archiveEdge(containerId, edgeId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Archives a node
     * @summary Archive Node
     * @param {string} containerId 
     * @param {string} nodeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public archiveNode(containerId: string, nodeId: string, options?: any) {
        return GraphApiFp(this.configuration).archiveNode(containerId, nodeId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Attach a file to an edge.
     * @summary Attach Edge File
     * @param {string} containerId 
     * @param {string} fileId 
     * @param {string} edgeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public attachEdgeFile(containerId: string, fileId: string, edgeId: string, options?: any) {
        return GraphApiFp(this.configuration).attachEdgeFile(containerId, fileId, edgeId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Attach a file to a node.
     * @summary Attach Node File
     * @param {string} containerId 
     * @param {string} nodeId 
     * @param {string} fileId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public attachNodeFile(containerId: string, nodeId: string, fileId: string, options?: any) {
        return GraphApiFp(this.configuration).attachNodeFile(containerId, nodeId, fileId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint will attempt to create a connection between two nodes. You can either pass in the node's Deep Lynx IDs, or the node's original id, metatype id, and data source id to create these edges.
     * @summary Create or Update Edges
     * @param {string} containerId 
     * @param {CreateOrUpdateEdgesRequest} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public createOrUpdateEdges(containerId: string, body?: CreateOrUpdateEdgesRequest, options?: any) {
        return GraphApiFp(this.configuration).createOrUpdateEdges(containerId, body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint will either create new nodes or update nodes if one with the same original_id is passed.
     * @summary Create Or Update Nodes
     * @param {CreateOrUpdateNodesRequest} body 
     * @param {string} containerId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public createOrUpdateNodes(body: CreateOrUpdateNodesRequest, containerId: string, options?: any) {
        return GraphApiFp(this.configuration).createOrUpdateNodes(body, containerId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Detach file from node
     * @summary Detach Node File
     * @param {string} containerId 
     * @param {string} nodeId 
     * @param {string} fileId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public deleteNodeFile(containerId: string, nodeId: string, fileId: string, options?: any) {
        return GraphApiFp(this.configuration).deleteNodeFile(containerId, nodeId, fileId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Detach file from an edge.
     * @summary Detach Node File
     * @param {string} containerId 
     * @param {string} fileId 
     * @param {string} edgeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public detachNodeFile(containerId: string, fileId: string, edgeId: string, options?: any) {
        return GraphApiFp(this.configuration).detachNodeFile(containerId, fileId, edgeId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all attached files for edge.
     * @summary List Edge Files
     * @param {string} containerId 
     * @param {string} edgeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public listEdgeFiles(containerId: string, edgeId: string, options?: any) {
        return GraphApiFp(this.configuration).listEdgeFiles(containerId, edgeId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List Edges from storage
     * @summary List Edges
     * @param {string} containerId 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [originID] 
     * @param {string} [destinationID] 
     * @param {string} [relationshipPairID] 
     * @param {string} [relationshipPairName] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public listEdges(containerId: string, limit?: number, offset?: number, originID?: string, destinationID?: string, relationshipPairID?: string, relationshipPairName?: string, options?: any) {
        return GraphApiFp(this.configuration).listEdges(containerId, limit, offset, originID, destinationID, relationshipPairID, relationshipPairName, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Lists all attached files for node.
     * @summary List Node Files
     * @param {string} containerId 
     * @param {string} nodeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public listNodeFiles(containerId: string, nodeId: string, options?: any) {
        return GraphApiFp(this.configuration).listNodeFiles(containerId, nodeId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List nodes
     * @summary List Nodes
     * @param {string} containerId 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {string} [transformationID] Return only nodes for the selected type transformation
     * @param {string} [metatypeID] Return only nodes for the selected metatype
     * @param {string} [dataSourceID] Return only nodes for the selected datasource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public listNodes(containerId: string, limit?: number, offset?: number, transformationID?: string, metatypeID?: string, dataSourceID?: string, options?: any) {
        return GraphApiFp(this.configuration).listNodes(containerId, limit, offset, transformationID, metatypeID, dataSourceID, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List Nodes, filter by MetatypeID
     * @summary List Nodes By Metatype ID
     * @param {string} containerId 
     * @param {string} metatypeId 
     * @param {number} [limit] 
     * @param {number} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public listNodesByMetatypeID(containerId: string, metatypeId: string, limit?: number, offset?: number, options?: any) {
        return GraphApiFp(this.configuration).listNodesByMetatypeID(containerId, metatypeId, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve a single edge
     * @summary Retrieve Edge
     * @param {string} containerId 
     * @param {string} edgeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public retrieveEdge(containerId: string, edgeId: string, options?: any) {
        return GraphApiFp(this.configuration).retrieveEdge(containerId, edgeId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve a single node from storage.
     * @summary Retrieve Node
     * @param {string} containerId 
     * @param {string} nodeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public retrieveNode(containerId: string, nodeId: string, options?: any) {
        return GraphApiFp(this.configuration).retrieveNode(containerId, nodeId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve n layers of node-edge relationships given a depth n and an origin node id.
     * @summary Nth Node Query
     * @param {string} containerId 
     * @param {string} nodeId 
     * @param {string} [depth] Number of layers deep to query. Defaults to 10.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public retrieveNthNodes(containerId: string, nodeId: string, depth?: string, options?: any) {
        return GraphApiFp(this.configuration).retrieveNthNodes(containerId, nodeId, depth, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This is an endpoint that accepts a GraphQL query and returns the results of that query. Primarily used for working with time series data on nodes.
     * @summary Timeseries Node Query
     * @param {string} containerId 
     * @param {string} nodeId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GraphApi
     */
    public timeseriesNodeQuery(containerId: string, nodeId: string, options?: any) {
        return GraphApiFp(this.configuration).timeseriesNodeQuery(containerId, nodeId, options).then((request) => request(this.axios, this.basePath));
    }
}
